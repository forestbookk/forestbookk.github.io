<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Operate System</title>
      <link href="/2024/06/05/Operate-System/"/>
      <url>/2024/06/05/Operate-System/</url>
      
        <content type="html"><![CDATA[<h1 id="Operate-System"><a href="#Operate-System" class="headerlink" title="Operate System"></a>Operate System</h1><h2 id="0-试卷资源"><a href="#0-试卷资源" class="headerlink" title="0 试卷资源"></a>0 试卷资源</h2><p><a href="https://www.docin.com/p-4664837653.html" target="_blank" rel="noopener">模拟</a></p><h2 id="1-考纲"><a href="#1-考纲" class="headerlink" title="1 考纲"></a>1 考纲</h2><ul><li><p>了解操作系统<strong>各个组成部分</strong>的基本结构和原理</p></li><li><p><strong>掌握</strong>在<strong>进程管理</strong>、<strong>存储管理</strong>、<strong>设备管理</strong>、<strong>磁盘管理</strong>及<strong>文件管理</strong>等涉及的概念和相关算法</p></li></ul><h2 id="2-引论"><a href="#2-引论" class="headerlink" title="2 引论"></a>2 引论</h2><h3 id="2-1-冯·诺伊曼体系结构"><a href="#2-1-冯·诺伊曼体系结构" class="headerlink" title="2.1 冯·诺伊曼体系结构"></a>2.1 冯·诺伊曼体系结构</h3><p>==存储程序式，集中顺序过程控制==</p><h4 id="2-1-1-组成"><a href="#2-1-1-组成" class="headerlink" title="2.1.1 组成"></a>2.1.1 组成</h4><ul><li>中央处理单元</li><li>存储器</li><li>输入输出</li></ul><h4 id="2-1-2-架构局限"><a href="#2-1-2-架构局限" class="headerlink" title="2.1.2 架构局限"></a>2.1.2 架构局限</h4><p>§ CPU与内存的交互引起的内存墙问题</p><p>§ 数据与指令不区分，指令等数据或数据等指令</p><p>§ 串行顺序处理，缺乏数据并行能力</p><h3 id="2-2-操作系统的发展变化"><a href="#2-2-操作系统的发展变化" class="headerlink" title="2.2 操作系统的发展变化"></a>2.2 操作系统的发展变化</h3><h4 id="2-2-1-批处理系统"><a href="#2-2-1-批处理系统" class="headerlink" title="2.2.1 批处理系统"></a>2.2.1 批处理系统</h4><h5 id="2-2-1-1-定义"><a href="#2-2-1-1-定义" class="headerlink" title="2.2.1.1 定义"></a>2.2.1.1 定义</h5><p>加载在计算机上的一个系统软件，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。</p><h5 id="2-2-1-2-分类"><a href="#2-2-1-2-分类" class="headerlink" title="2.2.1.2 分类"></a>2.2.1.2 分类</h5><ul><li><p>联机批处理系统：即作业的输入/输出由CPU来处理。出现“忙等”。</p></li><li><p>脱机批处理系统：为克服与缓解高速主机与慢速外设的矛盾，提高CPU的利用率，又引入了脱机批处理系统，即输入/输出脱离主机控制</p></li></ul><h4 id="2-2-2-多道程序系统"><a href="#2-2-2-多道程序系统" class="headerlink" title="2.2.2 多道程序系统"></a>2.2.2 多道程序系统</h4><p>不仅使CPU得到充分利用，同时也改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（即单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p><p>标志着操作系统渐趋成熟的阶段，先后出现了作业调度管理、处理机管理、存储器管理、外部设备管理、文件系统管理等功能。</p><p><strong>特点：</strong></p><ol><li>多道</li><li>宏观上并行</li><li>微观上串行</li></ol><p><strong>优点：</strong></p><ul><li>系统吞吐量大</li><li>资源利用率高</li></ul><p><strong>缺点：</strong></p><ul><li>平均周转时间长</li><li>不能提供交互能力</li></ul><h4 id="2-2-3-分时系统"><a href="#2-2-3-分时系统" class="headerlink" title="2.2.3 分时系统"></a>2.2.3 分时系统</h4><h5 id="2-2-3-1-定义"><a href="#2-2-3-1-定义" class="headerlink" title="2.2.3.1 定义"></a>2.2.3.1 定义</h5><p>多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源。</p><h5 id="2-2-3-2-特点"><a href="#2-2-3-2-特点" class="headerlink" title="2.2.3.2 特点"></a>2.2.3.2 特点</h5><ul><li>多路性</li><li>独立性：用户相互不打扰</li><li>及时性：响应时间</li><li>交互性：人机对话</li></ul><h4 id="2-2-4-实时、网络、分布式"><a href="#2-2-4-实时、网络、分布式" class="headerlink" title="2.2.4 实时、网络、分布式"></a>2.2.4 实时、网络、分布式</h4><h5 id="2-2-4-1-实时"><a href="#2-2-4-1-实时" class="headerlink" title="2.2.4.1 实时"></a>2.2.4.1 实时</h5><p>• 及时响应</p><p>• 高可靠性和安全性</p><p>• 系统的整体性强</p><p>• 交互会话活动较弱</p><p>• 专用系统</p><p>• 种类：实时信息处理、实时控制</p><h5 id="2-2-4-2-网络"><a href="#2-2-4-2-网络" class="headerlink" title="2.2.4.2 网络"></a>2.2.4.2 网络</h5><p>==联网==功能，资源的==远程访问==</p><h5 id="2-2-4-3-分布式"><a href="#2-2-4-3-分布式" class="headerlink" title="2.2.4.3 分布式"></a>2.2.4.3 分布式</h5><p>定义：在整个系统中有一个==全局==的操作系统</p><p>多台机器统一管理形成==单一系统==，相比网络，对用户和应用高度==透明==。具有多级合作和健壮性。</p><ul><li>==数据==透明</li><li>==执行==透明</li><li>==保护==透明</li></ul><h3 id="2-3-操作系统的主要功能"><a href="#2-3-操作系统的主要功能" class="headerlink" title="2.3 操作系统的主要功能"></a>2.3 操作系统的主要功能</h3><p>• 提供==解决各种冲突==（资源竞争引起）的策略</p><p>– 处理机调度、进程调度、内存分配、设备分配等</p><p>• ==协调并发活动==的关系（提供流程控制和避免运行</p><p>结果不确定性）</p><p>– 进程之间的通信，同步与互斥</p><p>• ==保证数据的一致性==</p><p>– 读写数据时，数据结构中的内容是否真实地记录了数</p><p>据的实际情况</p><p>– 在分布式处理时的共享数据的不同副本是否一致</p><p>• 实现==数据的存取控制==</p><p>– 共享程度、隐私程度、安全程度的控制</p><h4 id="2-3-1-进程管理（处理机分配）"><a href="#2-3-1-进程管理（处理机分配）" class="headerlink" title="2.3.1 进程管理（处理机分配）"></a>2.3.1 进程管理（处理机分配）</h4><h5 id="2-3-1-1-核心任务：如何分配CPU时间"><a href="#2-3-1-1-核心任务：如何分配CPU时间" class="headerlink" title="2.3.1.1 核心任务：如何分配CPU时间"></a>2.3.1.1 核心任务：如何分配CPU时间</h5><ul><li>进程管理<ul><li>进程的调度：创建、挂起、激活</li><li>进程间的通信：同步、互斥、死锁</li></ul></li><li>线程管理</li></ul><h5 id="2-3-1-2-主要功能"><a href="#2-3-1-2-主要功能" class="headerlink" title="2.3.1.2 主要功能"></a>2.3.1.2 主要功能</h5><ul><li>公平分配</li><li>保证非阻塞</li><li>按优先级分配</li></ul><h4 id="2-3-2-存储管理"><a href="#2-3-2-存储管理" class="headerlink" title="2.3.2 存储管理"></a>2.3.2 存储管理</h4><h5 id="2-3-2-1-核心任务"><a href="#2-3-2-1-核心任务" class="headerlink" title="2.3.2.1 核心任务"></a>2.3.2.1 核心任务</h5><p>管理缓存、主存、磁盘等所形成的多级存储架构，为多道程序的并发提供良好的环境</p><h5 id="2-3-2-2-主要功能"><a href="#2-3-2-2-主要功能" class="headerlink" title="2.3.2.2 主要功能"></a>2.3.2.2 主要功能</h5><ul><li>内存分配和存储无关性</li><li>内存保护：互不干扰</li><li>内存扩充：虚拟存储器</li></ul><h4 id="2-3-3-设备管理（包括磁盘管理）"><a href="#2-3-3-设备管理（包括磁盘管理）" class="headerlink" title="2.3.3 设备管理（包括磁盘管理）"></a>2.3.3 设备管理（包括磁盘管理）</h4><h5 id="2-3-3-1-核心任务"><a href="#2-3-3-1-核心任务" class="headerlink" title="2.3.3.1 核心任务"></a>2.3.3.1 核心任务</h5><p>管理输入/输出设备，屏蔽差异性，提供并发访问</p><h5 id="2-3-3-2-主要功能"><a href="#2-3-3-2-主要功能" class="headerlink" title="2.3.3.2 主要功能"></a>2.3.3.2 主要功能</h5><ul><li><p>设备无关性：逻辑设备-&gt;物理设备</p></li><li><p>设备分配：独享、共享和虚拟</p></li><li><p>设备的传输控制：<strong>中断</strong>、<strong>通道</strong></p></li></ul><h4 id="2-3-4-文件系统"><a href="#2-3-4-文件系统" class="headerlink" title="2.3.4 文件系统"></a>2.3.4 文件系统</h4><h5 id="2-3-4-1-核心任务"><a href="#2-3-4-1-核心任务" class="headerlink" title="2.3.4.1 核心任务"></a>2.3.4.1 核心任务</h5><p>将磁盘变成一个很容易使用的存储媒介提供给用户使用</p><h5 id="2-3-4-2-主要功能"><a href="#2-3-4-2-主要功能" class="headerlink" title="2.3.4.2 主要功能"></a>2.3.4.2 主要功能</h5><ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件读写管理</li><li>文件保护</li><li>向用户提供接口</li></ul><h4 id="2-3-5-接口管理"><a href="#2-3-5-接口管理" class="headerlink" title="2.3.5 接口管理"></a>2.3.5 接口管理</h4><h5 id="2-3-5-1-程序接口"><a href="#2-3-5-1-程序接口" class="headerlink" title="2.3.5.1 程序接口"></a>2.3.5.1 程序接口</h5><p>系统调用</p><h5 id="2-3-5-2-用户接口"><a href="#2-3-5-2-用户接口" class="headerlink" title="2.3.5.2 用户接口"></a>2.3.5.2 用户接口</h5><p>联机用户接口</p><p>脱机用户接口</p><p>图形用户接口</p><h3 id="2-4-现代操作系统的基本特征"><a href="#2-4-现代操作系统的基本特征" class="headerlink" title="2.4 现代操作系统的基本特征"></a>2.4 现代操作系统的基本特征</h3><ul><li><p>==并发==执行</p></li><li><p>资源==共享==</p></li><li><p>==虚拟化==管理：CPU, 存储器</p></li><li><p>==异步性==（不确定性事件的处理）</p></li></ul><h3 id="2-5-操作系统的工作模式"><a href="#2-5-操作系统的工作模式" class="headerlink" title="2.5 操作系统的工作模式"></a>2.5 操作系统的工作模式</h3><h4 id="2-5-1-内核态-管态"><a href="#2-5-1-内核态-管态" class="headerlink" title="2.5.1 内核态/管态"></a>2.5.1 内核态/管态</h4><p>运行操作系统程序</p><h4 id="2-5-2-用户态-目态"><a href="#2-5-2-用户态-目态" class="headerlink" title="2.5.2 用户态/目态"></a>2.5.2 用户态/目态</h4><p>运行用户程序</p><h4 id="2-5-3-切换过程？"><a href="#2-5-3-切换过程？" class="headerlink" title="2.5.3 切换过程？"></a>2.5.3 切换过程？</h4><p>内核与应用使用不同的页表。用户态无法直接寻址内核空间的数据。因此需要切换。</p><p>用户态—&gt;内核态：中断/异常/陷入机制</p><p>内核态—&gt;用户态：设置程序状态字PSW（MIPS的CP0寄存器）</p><h4 id="2-5-4-几个术语"><a href="#2-5-4-几个术语" class="headerlink" title="2.5.4 几个术语"></a>2.5.4 几个术语</h4><h5 id="2-5-4-1-特权指令-保护指令"><a href="#2-5-4-1-特权指令-保护指令" class="headerlink" title="2.5.4.1 特权指令/保护指令"></a>2.5.4.1 特权指令/保护指令</h5><p>只能由操作系统使用、用户程序不能使用的指令</p><h5 id="2-5-4-2-异常：中断、陷入（作用、区别？）（系统调用过程）"><a href="#2-5-4-2-异常：中断、陷入（作用、区别？）（系统调用过程）" class="headerlink" title="2.5.4.2 异常：中断、陷入（作用、区别？）（系统调用过程）"></a>2.5.4.2 异常：中断、陷入（作用、区别？）（系统调用过程）</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603141523948.png" alt="image-20240603141523948"></p><h5 id="2-5-4-3-系统调用的概念"><a href="#2-5-4-3-系统调用的概念" class="headerlink" title="2.5.4.3 系统调用的概念"></a>2.5.4.3 系统调用的概念</h5><p>系统调用提供用户程序与操作系统之间的接口，唯一接口使CPU状态从用户态陷入内核态</p><h4 id="2-5-5-系统调用和函数调用的区别"><a href="#2-5-5-系统调用和函数调用的区别" class="headerlink" title="2.5.5 系统调用和函数调用的区别"></a>2.5.5 系统调用和函数调用的区别</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603144212316.png" alt="image-20240603144212316"></p><h5 id="2-5-5-1-用户态程序如何访问系统功能，描述过程，如何切换入内核态执行"><a href="#2-5-5-1-用户态程序如何访问系统功能，描述过程，如何切换入内核态执行" class="headerlink" title="2.5.5.1 用户态程序如何访问系统功能，描述过程，如何切换入内核态执行"></a>2.5.5.1 用户态程序如何访问系统功能，描述过程，如何切换入内核态执行</h5><ol><li>CPU执行<code>int 0x2e</code>，CPU运行状态切换为系统态</li><li><p>当前进程使用的堆栈，从用户态切换到系统态。堆栈原先的内容（用户态），以及用户空间的堆栈指针，被压入系统空间堆栈。</p></li><li><p>从中断向量表中(<code>InterruptDescriptor Table</code>)以<code>0x2e</code>为中断向量，开始执行系统空间中的程序。</p></li><li><p>程序执行后，通过<code>iret</code>(中断返回)指令实现上述过程的逆过程</p></li></ol><blockquote><p>当CPU执行到特殊的陷入指令时</p><p>§ 中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序</p><p>§ 系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数</p><p>§ 执行系统调用例程</p><p>§ 恢复现场，返回用户程序</p></blockquote><h3 id="2-6-操作系统结构"><a href="#2-6-操作系统结构" class="headerlink" title="2.6 操作系统结构"></a>2.6 操作系统结构</h3><h4 id="2-6-1-计算机体系结构中的接口"><a href="#2-6-1-计算机体系结构中的接口" class="headerlink" title="2.6.1 计算机体系结构中的接口"></a>2.6.1 计算机体系结构中的接口</h4><ul><li>UI</li><li>API: API 定义了源代码和库之间的接口，因此同样的代码可以在支持这个 API 的任何系统中<strong>编译</strong> 。</li><li>ABI: 应用程序二进制接口, ABI 允许编译好的目标代码在使用兼容 ABI 的系统中无需改动就能<strong>运行</strong>。(2024期中三3)</li><li>ISA: ISA充当软件和硬件之间的接口，为ISA编写的软件可以在同一ISA的不同实现上运行。这使得可以轻松实现不同代计算机之间的二进制兼容性以及计算机家族的发展。</li></ul><p><img src="D:\BUAA\STAR\OS_LAB\img\接口.png" alt=""></p><h4 id="2-6-2-什么是操作系统内核？如何进入？"><a href="#2-6-2-什么是操作系统内核？如何进入？" class="headerlink" title="2.6.2 什么是操作系统内核？如何进入？"></a>2.6.2 什么是操作系统内核？如何进入？</h4><h4 id="2-6-3-微内核、整体内核（宏内核）"><a href="#2-6-3-微内核、整体内核（宏内核）" class="headerlink" title="2.6.3 微内核、整体内核（宏内核）"></a>2.6.3 微内核、整体内核（宏内核）</h4><h5 id="2-6-3-1-辨析"><a href="#2-6-3-1-辨析" class="headerlink" title="2.6.3.1 辨析"></a>2.6.3.1 辨析</h5><p>宏内核：<strong>整个系统分为内核与应用两层</strong></p><p>• 内核：运行在特权级，集中控制所有计算资源</p><p>• 应用：运行在非特权级，受内核管理，使用内核服务</p><p>微内核：内核中只包括中断处理、进程通信（IPC）、基本调度等。文件系统、网络功能、内存管理、设备管理等作为服务在微内核上运行。<strong>设计原则：最小化内核功能</strong></p><p>• 将操作系统功能移到用户态，称为服务（Server）</p><p>• 在用户模块之间，使用消息传递机制通信</p><h5 id="2-6-3-2-优缺点"><a href="#2-6-3-2-优缺点" class="headerlink" title="2.6.3.2 优缺点"></a>2.6.3.2 优缺点</h5><p>对<strong>宏内核</strong>而言</p><ul><li>优点：宏内核拥有丰富的沉淀和积累<ul><li>拥有巨大的统一的社区和生态</li><li>针对不同场景优化了30年</li></ul></li><li>缺点：<ul><li>安全性与可靠性问题：模块之间没有很强的隔离机制</li><li>实时性支持：系统太复杂导致无法做最坏情况时延分析</li><li>系统过于庞大而阻碍了创新：Linux代码行数已经过2千万</li></ul></li></ul><p>对<strong>微内核</strong>而言</p><ul><li>优点：内核易于实现、可移植性好、配置灵活、适应分布式环境（本地内核与远程内核对服务提供同样支持）、安全性高</li><li>缺点：速度较慢。（扩大内核减少切换；减少内核提高其他优点）</li></ul><blockquote><p>完整版：</p><p>§ <strong>优点</strong></p><p>• 易于扩展：直接添加一个用户进程即可为操作系统增加服务</p><p>• 易于移植：大部分模块与底层硬件无关</p><p>• 更加可靠：在内核模式运行的代码量大大减少</p><p>• 更加安全：即使存在漏洞，服务与服务之间存在进程粒度隔离</p><p>• 更加健壮：单个模块出现问题不会影响到系统整体</p><p>§ <strong>缺点</strong></p><p>• 性能较差：内核中的模块交互由函数调用变成了进程间通信</p><p>• 生态欠缺：尚未形成像Linux一样具有广泛开发者的社区</p><p>• 重用问题：重用宏内核操作系统提供兼容性，带来新问题</p></blockquote><h2 id="3-操作系统引导"><a href="#3-操作系统引导" class="headerlink" title="3 操作系统引导"></a>3 操作系统引导</h2><h3 id="3-1-OS分阶段引导过程"><a href="#3-1-OS分阶段引导过程" class="headerlink" title="3.1 OS分阶段引导过程"></a>3.1 OS分阶段引导过程</h3><ul><li><p>CPU通电启动或者Reset时，CPU从一个预定义的内存位置开始执行bootloader</p></li><li><p>bootloader程序一般存储于ROM只读存储器，因为RAM在系统启动时处于未知状态，而ROM它不需要初始化，也不容易被计算机病毒感染</p><blockquote><p>Bootloader需要正确地找到内核并加载执行，大部分分为stage1和stage2两个部分</p><p>§ <strong>Stage 1</strong></p><p>• 依赖于CPU体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现</p><p>• 需要初始化硬件设备，包括 watchdog timer、中断、时钟、内存等</p><p>• bootloader 程序直接从非易失存储器上（比如 ROM 或 FLASH）加载，为加载 stage2 准备 RAM 空间</p><p>§ <strong>Stage 2</strong></p><p>• 通常用C语言来实现，可实现复杂功能，更好的可读性和移植性</p><p>• 初始化这一阶段需要使用的硬件设备以及其他功能</p><p>• 将内核镜像从存储器读到 RAM 中，并为内核设置启动参数</p><p>• 将 CPU 指令寄存器的内容设置为内核入口函数的地址，即可将控制权从 bootloader 转交给操作系统内核</p></blockquote></li><li><p>通过bootloader，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备</p></li></ul><h3 id="3-2-各个阶段的职责"><a href="#3-2-各个阶段的职责" class="headerlink" title="3.2 各个阶段的职责"></a>3.2 各个阶段的职责</h3><ol><li><p>加载BIOS。BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。</p><blockquote><p>UEFI和BIOS的比较</p><p>二者显著的区别是：</p><p>§ EFI是用模块化，C语言风格的参数堆栈传递方式，动态链接的形式构建的系统，较BIOS而言更易于实现，容错和纠错特性更强，缩短了系统研发的时间。</p><p>§ 它运行于32位或64位模式，乃至未来增强的处理器模式下，突破传统BIOS的16位代码的寻址能力，达到处理器的最大寻址。</p></blockquote></li><li><p>读取MBR。硬盘上第0磁头第0磁道第1个扇区被称为MBR，即主引导记录，它的大小是512字节，存放了预启动信息、分区表信息。</p><ul><li>由于MBR的限制 只能有4个主分区，系统必须装在主分区上面。</li><li>硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。</li><li>一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干个。</li><li>主分区只能有一个是激活的（active），其余为inactive。</li></ul><blockquote><p>MBR组成：</p><p>§ MBR主引导记录包含两部分的内容，前446字节为启动代码及数据</p><p>§ 之后则是分区表（DPT, Disk Partition Table），分区表由四个分区项组成，每个分区项数据为16字节，记录了启动时需要的分区参数。这64个字节分布在MBR的第447-510字节</p><p>§ 后面紧接着两个字节AA和55被称为幻数, BOIS读取MBR的时候总是检查最后是不是有这两个幻数，如果没有就被认为是一个没有被分区的硬盘。</p></blockquote></li><li><p><strong>Boot Loader</strong></p><p>§ LILO 没有交互式命令界面，而 GRUB 拥有。</p><p>§ LILO 不支持网络引导，而 GRUB 支持。</p><p>§ LILO 将关于可以引导的操作系统位置的信息物理上存储在 MBR 中。如果修改了 LILO 配置文件，必须将 LILO 第一阶段引导加载程序重写到 MBR。错误配置的 MBR 可能会让系统无法引导。</p><p>§ 使用 GRUB，如果配置文件配置错误，则只是默认转到 GRUB 命令行界面。</p></li></ol><h3 id="3-3-各个阶段引导程序的存储与装载过程"><a href="#3-3-各个阶段引导程序的存储与装载过程" class="headerlink" title="3.3 各个阶段引导程序的存储与装载过程"></a>3.3 各个阶段引导程序的存储与装载过程</h3><p>程序的链接与装载：<strong>编译</strong>-<strong>链接</strong>-<strong>装载</strong>-<strong>执行</strong></p><p>程序一般由3个段组成，除此之外还需构建一个栈，一个堆：</p><ul><li>bss段：未初始化的全局变量，静态内存分配。<strong>不</strong>在可执行文件中，由系统初始化。</li><li>data段：已初始化的全局变量，static声明的变量，静态内存分配。在可执行文件中。</li><li>text段：用来存放程序执行代码的一块内存区域，可能包含一些只读的常数变量，例如字符串常量。在可执行文件中。</li><li>栈（stack）：存放、交换临时数据的内存区。存放程序局部变量（<strong>但不</strong>包括static声明的变量，static意味着在数据段中存放变量）</li><li>堆（heap）：动态分配的内存段，当进程调用malloc等函数，新分配的内存就被动态添加到堆上。</li></ul><h4 id="3-3-1-程序的装载细节"><a href="#3-3-1-程序的装载细节" class="headerlink" title="3.3.1 程序的装载细节"></a>3.3.1 程序的装载细节</h4><p>一个segment在文件中的大小是<strong>小于等于</strong>其在内存中的大小。如果在文件中的大小小于在内存应有的大小，载入时会<strong>补零</strong>直至应有的大小。</p><h3 id="3-4-简述Linux内核在x86平台上的加载过程"><a href="#3-4-简述Linux内核在x86平台上的加载过程" class="headerlink" title="3.4.简述Linux内核在x86平台上的加载过程"></a>3.4.简述Linux内核在x86平台上的加载过程</h3><h2 id="4-存储管理"><a href="#4-存储管理" class="headerlink" title="4 存储管理"></a>4 存储管理</h2><h3 id="4-1-存储管理的功能"><a href="#4-1-存储管理的功能" class="headerlink" title="4.1 存储管理的功能"></a>4.1 存储管理的功能</h3><h4 id="4-1-1-内存的分配与回收"><a href="#4-1-1-内存的分配与回收" class="headerlink" title="4.1.1 内存的分配与回收"></a>4.1.1 内存的分配与回收</h4><h4 id="4-1-2-存储保护"><a href="#4-1-2-存储保护" class="headerlink" title="4.1.2 存储保护"></a>4.1.2 存储保护</h4><h4 id="4-1-3-地址转换"><a href="#4-1-3-地址转换" class="headerlink" title="4.1.3 地址转换"></a>4.1.3 地址转换</h4><h4 id="4-1-4-静态重定位"><a href="#4-1-4-静态重定位" class="headerlink" title="4.1.4 静态重定位"></a>4.1.4 静态重定位</h4><p>• 当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换</p><p>• 一般可以由软件完成</p><h4 id="4-1-5-动态重定位"><a href="#4-1-5-动态重定位" class="headerlink" title="4.1.5 动态重定位"></a>4.1.5 动态重定位</h4><p>• 在进程执行过程中进行地址变换，<strong>即逐条指令执行时完成地址转换</strong></p><p>• 需要硬件部件支持</p><h4 id="4-1-6-存储共享"><a href="#4-1-6-存储共享" class="headerlink" title="4.1.6 存储共享"></a>4.1.6 存储共享</h4><h4 id="4-1-7-扩充内存容量"><a href="#4-1-7-扩充内存容量" class="headerlink" title="4.1.7 扩充内存容量"></a>4.1.7 扩充内存容量</h4><h3 id="4-2-分区存储管理"><a href="#4-2-分区存储管理" class="headerlink" title="4.2 分区存储管理"></a>4.2 分区存储管理</h3><h4 id="4-2-1-固定分区"><a href="#4-2-1-固定分区" class="headerlink" title="4.2.1 固定分区"></a>4.2.1 固定分区</h4><h5 id="4-2-1-1-基本思想"><a href="#4-2-1-1-基本思想" class="headerlink" title="4.2.1.1 基本思想"></a>4.2.1.1 基本思想</h5><p>采用的数据结构：分区表记录分区的大小和使用情况</p><h5 id="4-2-1-2-优缺点"><a href="#4-2-1-2-优缺点" class="headerlink" title="4.2.1.2 优缺点"></a>4.2.1.2 优缺点</h5><p><strong>§ 优点</strong></p><p>• 易于实现，开销小</p><p><strong>§ 缺点</strong></p><p>• 内部碎片，造成空间浪费</p><blockquote><h5 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h5><h6 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h6><p>分配大小大于实际使用</p><h6 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h6><p>空闲的但不连续，无法被使用，==外部碎片才是造成内存系统性能下降的主要原因==。</p><h6 id="如何消除内部碎片和外部碎片"><a href="#如何消除内部碎片和外部碎片" class="headerlink" title="如何消除内部碎片和外部碎片"></a>如何消除内部碎片和外部碎片</h6><ul><li><p>伙伴系统</p><p>介于固定分区与可变分区之间，其大小均为$2^{k}$。</p></li><li><p>紧凑技术</p><p>通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为紧凑（拼接或紧缩） 。</p><p>==实现支撑==：动态重定位。</p></li><li><p>段/页式内存管理</p></li></ul></blockquote><p>• 分区总数固定，限制了并发执行的程序数目</p><h4 id="4-2-2-可变分区"><a href="#4-2-2-可变分区" class="headerlink" title="4.2.2 可变分区"></a>4.2.2 可变分区</h4><h5 id="4-2-2-1-基本思想"><a href="#4-2-2-1-基本思想" class="headerlink" title="4.2.2.1 基本思想"></a>4.2.2.1 基本思想</h5><p>• 根据作业的实际需要，动态地为之分配内存空间</p><p>• 划分的时间、大小、位置都是动态的</p><h5 id="4-2-2-2-优缺点"><a href="#4-2-2-2-优缺点" class="headerlink" title="4.2.2.2 优缺点"></a>4.2.2.2 优缺点</h5><p>§ <strong>优点</strong></p><p>• 没有内碎片</p><p>• 克服固定分区内存资源的浪费问题，有利于多道程序设计，提高内存资源利用率</p><h5 id="4-2-2-3-动态分配数据结构"><a href="#4-2-2-3-动态分配数据结构" class="headerlink" title="4.2.2.3 动态分配数据结构"></a>4.2.2.3 动态分配数据结构</h5><ul><li><p>位图表示法（分区表）：给每个分配单元赋予一个字位，用来记录该分配单元是否闲置。例如，字位取值为0表示单元闲置，取值为1则表示已被占用</p><p>• 空间成本固定：不依赖于内存中的程序数量</p><p>• 时间成本低：操作简单，直接修改其位图值即可</p><p>• 没有容错能力：如果一个分配单元为1，不能肯定应该为1还是因错误变成1</p></li><li><p>链表表示法（分区链表）：将分配单元按照是否闲置链接起来，这种方法称为链表表示法。如上图所示的的位图所表示的内存分配状态</p><p>• 空间成本：取决于程序的数量</p><p>• 时间成本：链表扫描通常速度较慢，还要进行链表项的插入、删除和修改</p><p>• 有一定容错能力：因为链表有被占空间和闲置空间的表项，可以相互验证</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603214450192.png" alt="image-20240603214450192"></p></li></ul><h5 id="4-2-2-4-主要算法"><a href="#4-2-2-4-主要算法" class="headerlink" title="4.2.2.4 主要算法"></a>4.2.2.4 主要算法</h5><h6 id="BestFit"><a href="#BestFit" class="headerlink" title="BestFit"></a>BestFit</h6><p>往往使剩下的空闲区非常小，从而在存储器中留下许多难以利用的小空闲区</p><h6 id="WorstFit"><a href="#WorstFit" class="headerlink" title="WorstFit"></a>WorstFit</h6><p>大作业存储空间的申请往往会得不到满足</p><h6 id="FirstFit"><a href="#FirstFit" class="headerlink" title="FirstFit"></a>FirstFit</h6><ul><li><strong>优点：</strong></li></ul><p>• 分配和释放的时间性能较好</p><p>• 较大的空闲分区保留在内存的高端</p><ul><li><strong>缺点：</strong></li></ul><p>• 随着低端内存被不断分配，会产生很多小分区，开销会增大</p><h6 id="NextFit"><a href="#NextFit" class="headerlink" title="NextFit"></a>NextFit</h6><p>使存储空间的利用更加均衡，不致使小的空闲区集中在存储区的一端，但这会导致缺乏大的空闲分区</p><h4 id="4-2-3-覆盖与交换"><a href="#4-2-3-覆盖与交换" class="headerlink" title="4.2.3 覆盖与交换"></a>4.2.3 覆盖与交换</h4><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法，可以解决在小的内存空间运行大作业的问题。</p><h5 id="4-2-3-1-覆盖"><a href="#4-2-3-1-覆盖" class="headerlink" title="4.2.3.1 覆盖"></a>4.2.3.1 覆盖</h5><p>定义：把<strong>一个程序</strong>划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域。</p><p>原理：程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段。</p><p>要求：作业各模块之间有明确的调用结构，程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖。</p><p>缺点：对用户不透明，增加了用户负担。</p><h5 id="4-2-3-2-交换"><a href="#4-2-3-2-交换" class="headerlink" title="4.2.3.2 交换"></a>4.2.3.2 交换</h5><p>定义：把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移到辅存中去，以便腾出必要的存储空间；接着把指定程序或数据从辅存读到相应的主存中，并将控制转给它，让其在系统中运行。</p><p>优点：增加并发运行的程序数目，并且给用户提供适当的响应时间；编写程序时不影响程序结构。</p><p>缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑执行过程中地址访问的统计特性。</p><p>选择原则：等待I/O的进程。</p><p>交换时机的确定：只要不用就换出；只在内存空间不够或有不够的危险时换出。</p><h5 id="4-2-3-3-区别"><a href="#4-2-3-3-区别" class="headerlink" title="4.2.3.3 区别"></a>4.2.3.3 区别</h5><p>§ 覆盖可减少一个程序运行所需的空间。交换可让整个程序暂存于外存中，让出内存空间</p><p>§ 覆盖是由程序员实现的，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。交换技术不要求程序员给出程序段之间的覆盖结构</p><p>§ 覆盖技术主要对==同一个作业或程序==进行。交换主要在作业或程序间之间进行</p><h3 id="4-3-页式存储管理"><a href="#4-3-页式存储管理" class="headerlink" title="4.3 页式存储管理"></a>4.3 页式存储管理</h3><p>主要目的：==提高内存空间利用率==。页面与源程序==不存在逻辑关系==。</p><h4 id="4-3-1-页面、页框"><a href="#4-3-1-页面、页框" class="headerlink" title="4.3.1 页面、页框"></a>4.3.1 页面、页框</h4><ul><li>页/页面：在分页存储管理系统中，把每个作业的地址空间分成一些==大小相等的片==</li><li>存储块/页框：把主存的存储空间分成与==页面相同大小的片==</li></ul><h4 id="4-3-2-地址转换"><a href="#4-3-2-地址转换" class="headerlink" title="4.3.2 地址转换"></a>4.3.2 地址转换</h4><p>CPU地址划分为：虚拟页号+页内偏移。</p><p>如果逻辑地址空间为$2^m$，且页大小为$2^n$单元，那么逻辑地址的高m-n位表示页号（页表的索引），而低n位表示页偏移。</p><h5 id="4-3-2-1-MMU"><a href="#4-3-2-1-MMU" class="headerlink" title="4.3.2.1 MMU"></a>4.3.2.1 MMU</h5><h5 id="4-3-2-2-页表"><a href="#4-3-2-2-页表" class="headerlink" title="4.3.2.2 页表"></a>4.3.2.2 页表</h5><p>包含多个页表项，存储虚拟页到物理页的映射</p><h6 id="4-3-2-2-1-多级页表"><a href="#4-3-2-2-1-多级页表" class="headerlink" title="4.3.2.2.1 多级页表"></a>4.3.2.2.1 多级页表</h6><h6 id="4-3-2-2-2-杂凑页表"><a href="#4-3-2-2-2-杂凑页表" class="headerlink" title="4.3.2.2.2 杂凑页表"></a>4.3.2.2.2 杂凑页表</h6><h6 id="4-3-2-2-3-反置页表"><a href="#4-3-2-2-3-反置页表" class="headerlink" title="4.3.2.2.3 反置页表"></a>4.3.2.2.3 反置页表</h6><p>不是依据进程的逻辑页号来组织，而是依据该进程在内存中的物理页面号来组织（即：==按物理页面号排列==），其表项的内容是逻辑页号 P 及隶属进程标志符 pid</p><p>大小只与物理内存的大小相关，==优点：页表占用的内存空间小==</p><h5 id="4-3-2-3-快表TLB"><a href="#4-3-2-3-快表TLB" class="headerlink" title="4.3.2.3 快表TLB"></a>4.3.2.3 快表TLB</h5><p>一种特殊的高速缓冲存储器（Cache） ，内容是页表中的一部分或全部内容。</p><p>CPU 产生逻辑地址的页号，首先在快表中寻找，若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将之复制到快表。若快表中内容满，则按某种算法淘汰某些页</p><h5 id="4-3-2-4-页面的大小"><a href="#4-3-2-4-页面的大小" class="headerlink" title="4.3.2.4 页面的大小"></a>4.3.2.4 页面的大小</h5><p>最常用的页面大小为$4KB$。</p><p><strong>若页面较小</strong></p><p>• 减少页内碎片和总的内存碎片，有利于提高内存利用率。</p><p>• 每个进程页面数增多，使页表长度增加，占用内存较大。</p><p>• 页面换进换出速度将降低。</p><p><strong>若页面较大</strong></p><p>• 每个进程页面数减少，页表长度减少，占用内存较小。</p><p>• 页面换进换出速度将提高。</p><p>• 增加页内碎片，不利于提高内存利用率</p><h4 id="4-3-3-自映射"><a href="#4-3-3-自映射" class="headerlink" title="4.3.3 自映射"></a>4.3.3 自映射</h4><p>页目录表基址 $PD_{base}$:</p><p>$PD<em>{base}=PT</em>{base}|(PT_{base})&gt;&gt;10$</p><p>自映射目录表项$PDE_{self-mapping}$:</p><p>$PDE<em>{self-mapping}=PT</em>{base}|(PT<em>{base})&gt;&gt;10|(PT</em>{base})&gt;&gt;20$</p><h3 id="4-4-段式存储管理"><a href="#4-4-段式存储管理" class="headerlink" title="4.4 段式存储管理"></a>4.4 段式存储管理</h3><h4 id="4-4-1-基本思想"><a href="#4-4-1-基本思想" class="headerlink" title="4.4.1 基本思想"></a>4.4.1 基本思想</h4><p>主要是==满足用户（程序员）编程和使用要求==。程序更多采用分段结构，源程序经编译或汇编后，仍按照==自身逻辑关系分为若干段==。段之间的地址不一定连续，而段内地址一定连续。</p><ul><li>方便编程</li><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接</li></ul><h4 id="4-4-2-地址变换"><a href="#4-4-2-地址变换" class="headerlink" title="4.4.2 地址变换"></a>4.4.2 地址变换</h4><p>==二维地址结构（段号：段内地址）==。</p><p>这种地址结构需要编译程序的支持，但对程序员而言是透明的。</p><h4 id="4-4-3-分页与分段的比较（辨析异同）"><a href="#4-4-3-分页与分段的比较（辨析异同）" class="headerlink" title="4.4.3 分页与分段的比较（辨析异同）"></a>4.4.3 分页与分段的比较（辨析异同）</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603223443185.png" alt="image-20240603223443185"></p><ul><li><p>优点</p><p>分段系统易于实现段的共享，对段的保护也十分简单</p></li><li><p>缺点</p><ul><li>处理机要为地址变换花费时间；要为表格提供附加的存储空间</li><li>为满足分段的动态增长和减少外零头，要采用拼接手段。</li><li>在辅存中管理不定长度的分段困难较多</li><li>分段的最大尺寸受到主存可用空间的限制</li></ul></li></ul><h4 id="4-4-4-段页式内存管理"><a href="#4-4-4-段页式内存管理" class="headerlink" title="4.4.4 段页式内存管理"></a>4.4.4 段页式内存管理</h4><h5 id="4-4-4-1-基本思想"><a href="#4-4-4-1-基本思想" class="headerlink" title="4.4.4.1 基本思想"></a>4.4.4.1 基本思想</h5><p>用分段方法来分配和管理虚拟存储器，而用分页方法来分配和管理实存储器。</p><h5 id="4-4-4-2-实现原理"><a href="#4-4-4-2-实现原理" class="headerlink" title="4.4.4.2 实现原理"></a>4.4.4.2 实现原理</h5><ul><li><p>段页式存储管理是分段和分页原理的结合，即先将用户程序分成若干个段（段式） ，并为每一个段赋一个段名，再把每个段分成若干个页（页式） 。</p></li><li><p>其地址结构由段号、段内页号、及页内位移三部分所组成。</p></li><li>设段表和页表，均存放于内存中，读一字节的指令或数据须访问内存三次。每个进程一张段表，每个段一张页表。</li></ul><h3 id="4-5-虚拟存储：原理与算法"><a href="#4-5-虚拟存储：原理与算法" class="headerlink" title="4.5 虚拟存储：原理与算法"></a>4.5 虚拟存储：原理与算法</h3><p>自动实现部分装入和部分对装。</p><h4 id="4-5-1-内存访问的局部性原理"><a href="#4-5-1-内存访问的局部性原理" class="headerlink" title="4.5.1 内存访问的局部性原理"></a>4.5.1 内存访问的局部性原理</h4><p>指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。还可以表现为：</p><p>• ==时间局部性==，即一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；</p><p>• ==空间局部性==，即当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内。</p><h4 id="4-5-2-页面置换策略"><a href="#4-5-2-页面置换策略" class="headerlink" title="4.5.2 页面置换策略"></a>4.5.2 页面置换策略</h4><h5 id="最优算法：OPT"><a href="#最优算法：OPT" class="headerlink" title="最优算法：OPT"></a>最优算法：OPT</h5><p>页错误率最低，无法被实现。</p><p>淘汰页应是==以后不再访问==的页或==距现在最长时间后再访问的页==。</p><h5 id="先进先出：FIFO"><a href="#先进先出：FIFO" class="headerlink" title="先进先出：FIFO"></a>先进先出：FIFO</h5><p>淘汰页：==最先调入内存==的页。</p><p>==性能较差==，有Belady现象。</p><blockquote><h6 id="Belady"><a href="#Belady" class="headerlink" title="Belady"></a>Belady</h6><p>在使用FIFO算法作为缺页置换算法时，分配的缺页增多，但缺页率反而提高。</p><p>在使用FIFO算法作为缓存算法时，同样也会遇到类似情况：增加缓存容量，但缓存命中率也会下降。</p></blockquote><h5 id="第二次机会算法SCR"><a href="#第二次机会算法SCR" class="headerlink" title="第二次机会算法SCR"></a>第二次机会算法SCR</h5><p>==改进的FIFO==。其思想：“如果被淘汰的数据之前被访问过，则给其第二次机会”。</p><h5 id="时钟算法：Clock"><a href="#时钟算法：Clock" class="headerlink" title="时钟算法：Clock"></a>时钟算法：Clock</h5><p>==改进的FIFO==，也称最近未使用算法（NRU），通过一个环形队列，避免将数据在FIFO队列中移动。</p><h5 id="FIFO类算法对比"><a href="#FIFO类算法对比" class="headerlink" title="FIFO类算法对比"></a>FIFO类算法对比</h5><div class="table-container"><table><thead><tr><th>对比点</th><th>对比</th></tr></thead><tbody><tr><td>命中率</td><td><strong>Clock = SCR &gt; FIFO</strong></td></tr><tr><td>复杂度</td><td><strong>SCR &gt; Clock &gt; FIFO</strong></td></tr><tr><td>代价</td><td><strong>SCR &gt; Clock &gt; FIFO</strong></td></tr></tbody></table></div><h5 id="最近最少使用：LRU"><a href="#最近最少使用：LRU" class="headerlink" title="最近最少使用：LRU"></a>最近最少使用：LRU</h5><p>思想：“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p>局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p><h5 id="老化算法：AGING"><a href="#老化算法：AGING" class="headerlink" title="老化算法：AGING"></a>老化算法：AGING</h5><p>==LRU的简化，但性能接近LRU==。为每个页码设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入。</p><h5 id="最不频繁使用：LFU"><a href="#最不频繁使用：LFU" class="headerlink" title="最不频繁使用：LFU"></a>最不频繁使用：LFU</h5><h5 id="工作集策略"><a href="#工作集策略" class="headerlink" title="工作集策略"></a>工作集策略</h5><p>进程的==工作集==：当前正在使用的页面的集合；</p><p>进程的==驻留集==：虚拟存储系统中，每个进程驻留在内存的页面集合，或进程分到的物理页框集合。</p><p>引入工作集的目的：依据进程在过去的一段时间内访问的页面来调整驻留集大小。</p><p>工作集策略：NT根据内存负荷和进程缺页情况自动调整工作集。进程创建时，指定一个最小工作集，当内核负荷不太大时，允许进程拥有尽可能多的页面；系统通过自动调整保证内存中有一定的空闲页面存在。</p><h4 id="4-5-3-缺页中断率"><a href="#4-5-3-缺页中断率" class="headerlink" title="4.5.3 缺页中断率"></a>4.5.3 缺页中断率</h4><h3 id="4-6-其他内容"><a href="#4-6-其他内容" class="headerlink" title="4.6 其他内容"></a>4.6 其他内容</h3><h4 id="4-6-1-内存抖动"><a href="#4-6-1-内存抖动" class="headerlink" title="4.6.1 内存抖动"></a>4.6.1 内存抖动</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>随着驻留内存的进程数目增加，或者说进程并发水平的上升，处理器利用率先是上升，然后下降。这里下降的原因通常称为虚拟存储器发生“抖动”，即每个进程的驻留集不断减小，当驻留集小于工作集后，缺页率急剧上升频繁调页使得调页开销增大。</p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul><li>局部置换策略（微观层面）：正在抖动的进程不能从另外的进程夺取内存块。并未消除抖动的发生。</li><li>引入工作集算法（微观）</li><li>预留部分页面（微观或宏观）</li><li>挂起若干进程：消除抖动现象（宏观）</li></ul><h4 id="4-6-2-写时复制技术"><a href="#4-6-2-写时复制技术" class="headerlink" title="4.6.2 写时复制技术"></a>4.6.2 写时复制技术</h4><h4 id="4-6-3-内存映射文件"><a href="#4-6-3-内存映射文件" class="headerlink" title="4.6.3 内存映射文件"></a>4.6.3 内存映射文件</h4><h4 id="4-6-4-存储保护"><a href="#4-6-4-存储保护" class="headerlink" title="4.6.4 存储保护"></a>4.6.4 存储保护</h4><h2 id="5-进程机制与并发程序设计"><a href="#5-进程机制与并发程序设计" class="headerlink" title="5 进程机制与并发程序设计"></a>5 进程机制与并发程序设计</h2><h3 id="5-1-进程与线程的基本概念"><a href="#5-1-进程与线程的基本概念" class="headerlink" title="5.1 进程与线程的基本概念"></a>5.1 进程与线程的基本概念</h3><h4 id="5-1-1-并发与并行"><a href="#5-1-1-并发与并行" class="headerlink" title="5.1.1 并发与并行"></a>5.1.1 并发与并行</h4><p>并发：设有两个活动a1和a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都在执行中，则称a1和a2是并发执行的。</p><p>并行：两个程序在某一指定的时间t，同时运行在<strong>不同</strong>的处理机上。</p><p>并行性的确定-Bernstein条件：两个进程S1和S2可并发，当且仅当下列条件同时成立：</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145415008.png" alt="image-20240604145415008"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145406288.png" alt="image-20240604145406288"></p><h4 id="5-1-2-进程与程序"><a href="#5-1-2-进程与程序" class="headerlink" title="5.1.2 进程与程序"></a>5.1.2 进程与程序</h4><p>程序：静态的。静态的实体，是存放在磁盘上的可执行文件</p><p>进程：动态的。执行中的程序。进程包括程序和程序处理对象（数据集），是一个程序对某个数据集的执行过程，是分配资源的基本单位。通常把进程分为系统进程和用户进程两大类。进程的三个特征：并发、共享、不确定性。</p><p>作业：用户需要计算机完成的某项任务，是要求计算机所做工作的集合</p><h4 id="5-1-3-进程的三个基本状态、转换条件"><a href="#5-1-3-进程的三个基本状态、转换条件" class="headerlink" title="5.1.3 进程的三个基本状态、转换条件"></a>5.1.3 进程的三个基本状态、转换条件</h4><ul><li>就绪状态：进程已获得除处理机外的所需资源，等待分配处理机资源；只要分配CPU就可执行；</li><li>执行状态：占用处理机资源；</li><li>阻塞状态：正在执行的进程由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。</li></ul><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145724107.png" alt="image-20240604145724107"></p><h4 id="5-1-4-进程的控制原语"><a href="#5-1-4-进程的控制原语" class="headerlink" title="5.1.4 进程的控制原语"></a>5.1.4 进程的控制原语</h4><p>原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能。</p><ul><li><p>特点</p><ol><li>指令序列执行是连续的，不可分割</li><li>是操作系统核心组成部分</li><li>必须在管态下执行，且常驻内存</li></ol></li><li><p>和系统调用的区别：</p><p><a href="https://blog.csdn.net/weixin_46248230/article/details/133207862" target="_blank" rel="noopener">原语是操作系统核心态下的原子性操作，强调原子性；系统调用是用户程序和操作系统的接口，为用户程序提供系统服务。原语常驻内存，必须在管态执行，而系统调用在用户态执行，对应的服务程序在内核态执行</a></p></li><li><p>创建原语：<code>fork</code>, <code>exec</code></p><p>==Fork()函数==：</p><p>fork调用仅仅被调用一次，却能返回两次，它可能有三种不同的返回值：</p><ol><li>在父进程中，fork返回新创建子进程的进程ID；</li><li>在子进程中，fork返回0；</li><li>如果出现错误，fork返回一个负值；</li></ol></li><li><p>撤销原语：<code>kill</code></p></li></ul><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145952434.png" alt="image-20240604145952434"></p><h4 id="5-1-5-进程的组成：程序、数据、PCB"><a href="#5-1-5-进程的组成：程序、数据、PCB" class="headerlink" title="5.1.5 进程的组成：程序、数据、PCB"></a>5.1.5 进程的组成：程序、数据、PCB</h4><h4 id="5-1-6-进程与线程的区别"><a href="#5-1-6-进程与线程的区别" class="headerlink" title="5.1.6 进程与线程的区别"></a>5.1.6 进程与线程的区别</h4><p>进程是资源拥有者，线程是可执行单元。</p><p>进程拥有虚空间、进程映像、处理机保护、文件、I/O空间。</p><p>线程额外的资源：运行状态、保存上下文（程序计数器）、执行栈、资源共享机制。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604164345788.png" alt="image-20240604164345788"></p><h4 id="5-1-7-线程的实现方式"><a href="#5-1-7-线程的实现方式" class="headerlink" title="5.1.7 线程的实现方式"></a>5.1.7 线程的实现方式</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604154833392.png" alt="image-20240604154833392"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604154854666.png" alt="image-20240604154854666"></p><h5 id="5-1-7-1-用户级线程"><a href="#5-1-7-1-用户级线程" class="headerlink" title="5.1.7.1 用户级线程"></a>5.1.7.1 用户级线程</h5><p>线程在用户空间，不需要或仅需要极少的kernel支持。</p><p>上下文切换比较快。</p><p>用户级的线程库的主要功能：</p><ul><li>创建和销毁线程</li><li>线程之间传递消息和数据</li><li>调度线程执行</li><li>保存和恢复线程上下文</li></ul><p><strong>优点</strong></p><ul><li>线程切换与内核无关</li><li>线程的调度由应用决定，容易进行优化</li><li>可运行在任何操作系统上，只需要线程库的支持</li></ul><p><strong>缺点</strong></p><ul><li>一个线程阻塞，所有相关的线程也会被内核阻塞。</li><li>阻塞发生在进程级别。内核只能将处理器分配给进程。即使有多个处理器，也无法实现一个进程中的多个线程的并发执行。</li></ul><h5 id="5-1-7-2-内核级线程"><a href="#5-1-7-2-内核级线程" class="headerlink" title="5.1.7.2 内核级线程"></a>5.1.7.2 内核级线程</h5><p>思想：kernel有好几个分身，一个分身可以处理一件事。</p><p><strong>优点</strong></p><ul><li>内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li><li>阻塞发生在线程级别</li><li>内核中的一些处理可以通过多线程实现</li></ul><p><strong>缺点</strong></p><ul><li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li><li>降低效率</li></ul><h5 id="5-1-7-3-混合实现方式"><a href="#5-1-7-3-混合实现方式" class="headerlink" title="5.1.7.3 混合实现方式"></a>5.1.7.3 混合实现方式</h5><p>线程在用户空间创建和管理。需要实现从用户空间的线程到内核空间线程（轻量级进程）的映射。</p><h3 id="5-2-进程调度算法"><a href="#5-2-进程调度算法" class="headerlink" title="5.2 进程调度算法"></a>5.2 进程调度算法</h3><h4 id="5-2-1-调度的三个类型：高级、中级、低级"><a href="#5-2-1-调度的三个类型：高级、中级、低级" class="headerlink" title="5.2.1 调度的三个类型：高级、中级、低级"></a>5.2.1 调度的三个类型：高级、中级、低级</h4><h5 id="5-2-1-1-高级调度-宏观调度-作业调度"><a href="#5-2-1-1-高级调度-宏观调度-作业调度" class="headerlink" title="5.2.1.1 高级调度/宏观调度/作业调度"></a>5.2.1.1 高级调度/宏观调度/作业调度</h5><p>==用户角度==，一次提交若干个作业，对每个作业进行调度。</p><h5 id="5-2-1-2-中级调度-内外存交换"><a href="#5-2-1-2-中级调度-内外存交换" class="headerlink" title="5.2.1.2 中级调度/内外存交换"></a>5.2.1.2 中级调度/内外存交换</h5><p>==存储器资源管理==的角度，将进程的部分或全部换出到外存上，将当前所需部分换入到内存。</p><h5 id="5-2-2-1-3-低级调度-微观调度-进程或线程调度"><a href="#5-2-2-1-3-低级调度-微观调度-进程或线程调度" class="headerlink" title="5.2.2=1.3 低级调度/微观调度/进程或线程调度"></a>5.2.2=1.3 低级调度/微观调度/进程或线程调度</h5><p>==CPU资源管理==的角度，执行的单位。</p><h4 id="5-2-2-进程调度算法"><a href="#5-2-2-进程调度算法" class="headerlink" title="5.2.2 进程调度算法"></a>5.2.2 进程调度算法</h4><h5 id="5-2-2-1-总体上：非抢占、抢占"><a href="#5-2-2-1-总体上：非抢占、抢占" class="headerlink" title="5.2.2.1 总体上：非抢占、抢占"></a>5.2.2.1 总体上：非抢占、抢占</h5><p>抢占即，就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，立即进行进程调度。</p><h5 id="5-2-2-2-评价指标："><a href="#5-2-2-2-评价指标：" class="headerlink" title="5.2.2.2 评价指标："></a>5.2.2.2 <strong>评价指标：</strong></h5><p>–<strong>周转时间、平均周转时间、带权平均周转时间</strong></p><ul><li>$周转时间=完成时刻-提交时刻$</li><li>$带权周转时间=周转时间/服务时间(执行时间)$</li><li>$平均周转时间=作业周转时间之和/作业数$</li><li>$平均带权周转时间=作业带权周转时间之和/作业数$</li></ul><p>–<strong>吞吐量</strong></p><p>$吞吐量=作业数/总执行时间$，即单位时间CPU完成的作业数量</p><p>–<strong>响应时间</strong></p><h5 id="5-2-2-3-常见调度算法"><a href="#5-2-2-3-常见调度算法" class="headerlink" title="5.2.2.3 常见调度算法"></a>5.2.2.3 常见调度算法</h5><h6 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h6><p>最简单的调度算法，按先后顺序调度。非抢占式。</p><p>比较有利于长作业、CPU繁忙的作业。不适合短作业、I/O繁忙的作业。</p><h6 id="短作业优先SJF"><a href="#短作业优先SJF" class="headerlink" title="短作业优先SJF"></a>短作业优先SJF</h6><p>对FCFS的改进，目标：减少平均周转时间</p><p>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢占正在执行的作业。</p><p>优点：比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间。提高系统的吞吐量。</p><p>缺点：对长作业非常不利。未能依据作业的紧迫程度来划分执行的优先级；难以准确估计执行时间从而影响调度性能。</p><h6 id="最短剩余时间优先SRTN"><a href="#最短剩余时间优先SRTN" class="headerlink" title="最短剩余时间优先SRTN"></a>最短剩余时间优先SRTN</h6><p>对SJF的改进，改进为==抢占式==。即一个新就绪的进程比当前运行进程具有更短的完成时间，系统抢占当前进程。</p><p>缺点：长任务==饥饿==。</p><h6 id="最高响应比优先HRRN"><a href="#最高响应比优先HRRN" class="headerlink" title="最高响应比优先HRRN"></a>最高响应比优先HRRN</h6><p>FCFS和SJF的折中。非抢占式。既考虑作业的运行时间，也考虑作业的运行时间。既照顾短作业又不使长作业的等待时间过长。</p><p>计算后备作业队列中每个作业的响应比RP，然后选择其值最大的作业投入运行。RP值定义为：</p><p>$RP=(作业已等待时间+作业的服务时间)/作业的服务时间=1+作业已等待时间/作业的服务时间$</p><p>饥饿现象不会发生。但每次计算各道作业的响应比会有一定的时间开销。</p><h6 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h6><p>微观调度，目标：提高资源利用率。时间片过长会退化为FCFS算法。</p><p>算法流程：</p><p>§ <strong>将系统中所有的就绪进程按照FCFS原则，排成一个队列。</strong></p><p>§ <strong>每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。</strong></p><p>§ <strong>在一个时间片结束时，发生时钟中断。</strong></p><p>§ <strong>调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</strong></p><p>§ <strong>进程可以未使用完一个时间片，就出让CPU（如阻塞）。</strong></p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>可分成抢先式和非抢先式。</p><ul><li>静态优先级：创建进程时就确定，直到进程终止前都不改变。</li><li>动态优先级：在创建进程时赋予的优先级，在进程运行过程中可以自动改变。</li><li>优先级倒置（反转）：高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。解决方法：<ol><li>优先级置顶。当进程进入临界区后，其占用的处理机就不允许被抢占。</li><li>优先级继承。当高优先级进程要进入临界区使用临界资源X时，如果已经有一个低优先级进程正在使用该资源，则可以优先级继承。</li></ol></li></ul><h6 id="多级反馈队列算法MFQ"><a href="#多级反馈队列算法MFQ" class="headerlink" title="多级反馈队列算法MFQ"></a>多级反馈队列算法MFQ</h6><p>时间片轮转算法和优先级算法的综合和发展。</p><h5 id="5-2-2-4-实时调度算法"><a href="#5-2-2-4-实时调度算法" class="headerlink" title="5.2.2.4 实时调度算法"></a>5.2.2.4 实时调度算法</h5><h6 id="单调速率调度RMS"><a href="#单调速率调度RMS" class="headerlink" title="单调速率调度RMS"></a>单调速率调度RMS</h6><p>单处理器下的==最优静态调度算法==。可通过对系统资源利用率的计算来进行任务可调度性分析。实时调度的基础性理论。</p><p>任务的周期越小，其优先级越高。优先级最高的任务最先被调度。如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度。</p><h6 id="最早截止时间优先算法EDF"><a href="#最早截止时间优先算法EDF" class="headerlink" title="最早截止时间优先算法EDF"></a>最早截止时间优先算法EDF</h6><p>任务的绝对截止时间越早，其优先级越高。</p><p>任务集可调度的充分必要条件：</p><p>$\sum_{i=1}^{n}\frac{C_i}{T_i}\leqslant1$</p><h6 id="最低松弛度优先算法LLF"><a href="#最低松弛度优先算法LLF" class="headerlink" title="最低松弛度优先算法LLF"></a>最低松弛度优先算法LLF</h6><p>根据任务紧急的程度，来确定任务的优先级。任务的紧急度越高，其优先级越高，并使之优先执行。</p><p>==$松弛度=任务截止时间-本身剩余运行时间-当前时间$==</p><p>调度时机：有进程执行完或有进程的松弛度（Laxity）为0时</p><p>任务集可调度的充分必要条件：</p><p>$\sum_{i=1}^{n}\frac{C_i}{T_i}\leqslant1$</p><h4 id="5-2-3-多处理机调度"><a href="#5-2-3-多处理机调度" class="headerlink" title="5.2.3 多处理机调度"></a>5.2.3 多处理机调度</h4><h5 id="5-2-3-1-系统"><a href="#5-2-3-1-系统" class="headerlink" title="5.2.3.1 系统"></a>5.2.3.1 系统</h5><ul><li>非对称式多处理系统（AMP）</li><li>对称式多处理系统（SMP）<ol><li>自调度：所有CPU采用一个公共就绪队列。各个处理机自行在就绪队列中取任务。</li></ol></li></ul><h5 id="5-2-3-2-调度"><a href="#5-2-3-2-调度" class="headerlink" title="5.2.3.2 调度"></a>5.2.3.2 调度</h5><ul><li>自调度</li><li>成组调度</li><li>专用处理机调度</li></ul><h3 id="5-3-进程通信"><a href="#5-3-进程通信" class="headerlink" title="5.3 进程通信"></a>5.3 进程通信</h3><h4 id="5-3-1-类型"><a href="#5-3-1-类型" class="headerlink" title="5.3.1 类型"></a>5.3.1 类型</h4><h5 id="5-3-1-1-低级通信"><a href="#5-3-1-1-低级通信" class="headerlink" title="5.3.1.1 低级通信"></a>5.3.1.1 低级通信</h5><p>只能传递状态和整数值，包括进程互斥和同步所采用的信号量和管程机制。</p><p>缺点：传送信息量小、编程复杂。</p><h5 id="5-3-1-2-高级通信"><a href="#5-3-1-2-高级通信" class="headerlink" title="5.3.1.2 高级通信"></a>5.3.1.2 高级通信</h5><ul><li>==管道==<ol><li>无名管道（Pipe）：<ul><li>==半双工==，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><li>==只能用于父子进程或兄弟进程==之间（具有亲缘关系的进程）；</li><li>单独构成一种==独立的文件系统==，==只存在内存中==；</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul></li><li>有名管道（Named Pipe或FIFO）<ul><li>可以用于能够访问FIFO路径的进程以及FIFO的创建进程之间。因此通过FIFO不相关的进程也能交换数据；</li><li>严格遵循先进先出，数据的读出和写入同无名管道。</li></ul></li></ol></li><li>==共享内存==<ol><li>==最有用==的进程间通信方式，也是==最快==的IPC形式（原因：避免了其他形式的IPC必须执行的开销巨大的缓冲复制）</li><li>两个不同进程A、B共享内存的意义是，==同一块物理内存被映射到进程A、B各自的进程地址空间==。</li><li>当多个进程共享同一块内存区域，由于共享内存可以同时读但不能同时写</li></ol></li><li>==消息系统==<ol><li>消息传递：两个通信原语（<code>send</code>, <code>receive</code>）</li><li>调用方式：阻塞调用、非阻塞调用</li></ol></li></ul><h4 id="5-3-2-临界资源、临界区"><a href="#5-3-2-临界资源、临界区" class="headerlink" title="5.3.2 临界资源、临界区"></a>5.3.2 临界资源、临界区</h4><p>临界资源：一次仅允许一个进程访问的资源；</p><p>临界区：每个进程中访问临界资源的那段代码；</p><h4 id="5-3-3-同步、互斥"><a href="#5-3-3-同步、互斥" class="headerlink" title="5.3.3 同步、互斥"></a>5.3.3 同步、互斥</h4><p>互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。访问是==无需访问==。==（间接制约关系）==</p><p>同步：在互斥的基础上，通过其他机制实现访问者对资源的==有序访问==。==（直接制约关系）==</p><h5 id="5-3-3-1-原则"><a href="#5-3-3-1-原则" class="headerlink" title="5.3.3.1 原则"></a>5.3.3.1 原则</h5><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><h5 id="5-3-3-2-经典问题"><a href="#5-3-3-2-经典问题" class="headerlink" title="5.3.3.2 经典问题"></a>5.3.3.2 经典问题</h5><blockquote><p>全面练习：孙海龙-13-4.2-进程管理-同步与互斥.ppt</p></blockquote><h6 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h6><p>若干进程通过有限的共享缓冲区交换数据。</p><h6 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h6><h6 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h6><ul><li>破除==资源互斥==：至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放他所使用的两支筷子。</li><li>破除==循环等待==：对筷子进行编号，每个哲学家按编号从低到高拿起筷子；或对哲学家编号，奇数先左后右，偶数相反。</li><li>破除==请求且保持==：同时拿起两根筷子，否则不拿起。</li></ul><h6 id="理发师"><a href="#理发师" class="headerlink" title="理发师"></a>理发师</h6><h4 id="5-3-4-信号量、PV操作"><a href="#5-3-4-信号量、PV操作" class="headerlink" title="5.3.4 信号量、PV操作"></a>5.3.4 信号量、PV操作</h4><p>信号量是一类特殊的变量，程序对其访问都是原子操作，且只允许对它进行P和V操作。</p><p>当信号量为正时，表示资源的个数；</p><p>当信号量为负时，表示等待进程的个数。</p><h5 id="5-3-4-1-优缺点"><a href="#5-3-4-1-优缺点" class="headerlink" title="5.3.4.1 优缺点"></a>5.3.4.1 优缺点</h5><ul><li>优点：简单，而且==表达能力强==（用PV操作可解决==任何==同步互斥问题）。</li><li>缺点：不够安全；PV操作使用不当会出现==死锁==；遇到复杂同步互斥问题时实现复杂。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span> </span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span> </span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span></span><br><span class="line">        <span class="comment">/* place process P on ready list</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="5-3-4-2-实现汇合（Rendezvous）"><a href="#5-3-4-2-实现汇合（Rendezvous）" class="headerlink" title="5.3.4.2 实现汇合（Rendezvous）"></a>5.3.4.2 实现汇合（Rendezvous）</h5><p>目的：a1永远在b2之前，而b1永远在a2之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore aArrived = <span class="number">0</span>, bArrived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread A */</span></span><br><span class="line">statement a1;</span><br><span class="line">V(aArrived);</span><br><span class="line">P(bArrived);</span><br><span class="line">statement a2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread B */</span></span><br><span class="line">statement b1;</span><br><span class="line">V(bArrived);</span><br><span class="line">P(aArrived);</span><br><span class="line">statement b2;</span><br></pre></td></tr></table></figure><h5 id="5-3-4-3-屏障Barriers"><a href="#5-3-4-3-屏障Barriers" class="headerlink" title="5.3.4.3 屏障Barriers"></a>5.3.4.3 屏障Barriers</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604161746827.png" alt="image-20240604161746827"></p><h5 id="5-3-4-4-信号量集机制"><a href="#5-3-4-4-信号量集机制" class="headerlink" title="5.3.4.4 信号量集机制"></a>5.3.4.4 信号量集机制</h5><p>▪ SP(S, d, d)：表示每次申请d个资源，当资源数量少于d个时，便不予分配。</p><p>▪ SP(S, 1, 1)：表示互斥信号量。</p><p>▪ SP(S, 1, 0)：可作为一个可控开关(当S≥1时，允许多个进程进入临界区；当S=0时禁止任何进程进入临界区)。</p><h4 id="5-3-5-管程的基本概念"><a href="#5-3-5-管程的基本概念" class="headerlink" title="5.3.5 管程的基本概念"></a>5.3.5 管程的基本概念</h4><p>是在==程序设计语言==中引入的一个==成分==，是一种高级同步机制。</p><p>管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。需要解决三个问题：互斥、同步、条件变量。</p><blockquote><h6 id="条件变量和信号量的区别："><a href="#条件变量和信号量的区别：" class="headerlink" title="条件变量和信号量的区别："></a>条件变量和信号量的区别：</h6><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604162313118.png" alt="image-20240604162313118"></p></blockquote><h3 id="5-4-死锁问题"><a href="#5-4-死锁问题" class="headerlink" title="5.4 死锁问题"></a>5.4 死锁问题</h3><h4 id="5-4-1-基本概念：死锁、活锁、饥饿"><a href="#5-4-1-基本概念：死锁、活锁、饥饿" class="headerlink" title="5.4.1 基本概念：死锁、活锁、饥饿"></a>5.4.1 基本概念：死锁、活锁、饥饿</h4><p>死锁：一组进程中，每个进程都无限等待组内其他进程所占有的资源，在无外力介入的条件下，将因永远分配不道德资源而无法运行的现象。浪费大量系统资源，甚至导致系统崩溃。发生原因：资源竞争、并发执行的顺序不当。</p><p>活锁：任务或执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败。活锁在不断地改变状态，且有可能自行解开。</p><p>饥饿：某些进程可能由于资源分配策略的不公平导致长时间等待。</p><h4 id="5-4-2-产生死锁的必要条件"><a href="#5-4-2-产生死锁的必要条件" class="headerlink" title="5.4.2 产生死锁的必要条件"></a>5.4.2 产生死锁的必要条件</h4><ul><li>互斥：允许进程同时访问某些资源。</li><li>不可剥夺：允许进程强行从占有者那里夺取资源。</li><li>请求和保持：实现资源预先分配。只有当系统能够满足当前进程的全部资源需求时，才一次性将所申请的资源全部分配给该进程，否则不分配任何进程。</li><li>循环等待：把资源实现分类编号，按号分配。</li></ul><h4 id="5-4-3-进程-资源图-资源分配图"><a href="#5-4-3-进程-资源图-资源分配图" class="headerlink" title="5.4.3 进程-资源图/资源分配图"></a>5.4.3 进程-资源图/资源分配图</h4><h4 id="5-4-4-处理死锁的方法"><a href="#5-4-4-处理死锁的方法" class="headerlink" title="5.4.4 处理死锁的方法"></a>5.4.4 处理死锁的方法</h4><ul><li><p>允许死锁发生：无作为、检测与解除死锁</p></li><li><p>不允许死锁发生：预防死锁、避免死锁</p><ul><li><p>预防死锁（静态）：破坏死锁产生的四个条件</p></li><li><p>避免死锁（动态）：在资源分配之前进行判断。安全性、银行家算法</p><ol><li><p>安全序列：一个序列${P_1,P_2,…,P_n}$安全，指若对于每一个进程$P_i$,它需要的资源可以被系统中当前可用资源加上所有进程$P_j(j&lt;i)$当前占有资源之和所满足。则这是一个安全序列。如果系统不存在这样一个安全序列，则系统是不安全的。系统进入不安全状态也未必产生死锁。产生死锁后，系统一定处于不安全状态。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604165458874.png" alt="image-20240604165458874"></p></li><li><p>银行家算法</p></li></ol></li></ul></li><li><p>检测与解除死锁：</p><ul><li>发现死锁：基于进程-资源图的化简<ol><li>资源分配图中存在环路，不一定存在死锁。</li><li>死锁定理：系统中某个时刻t为死锁状态的充要条件是==t时刻系统的资源分配图是不可完全化简的==。</li><li>在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是可完全化简的；反之的是不可完全化简的。</li></ol></li><li>解除死锁：资源剥夺、撤销进程<ol><li>剥夺资源：挂起一些进程，剥夺其资源以接触死锁，待条件满足时再激活。</li><li>撤销进程：使全部死锁的进程夭折。</li></ol></li><li>无所作为：鸵鸟算法</li></ul></li></ul><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604170307930.png" alt="image-20240604170307930"></p><h2 id="6-输入-输出系统"><a href="#6-输入-输出系统" class="headerlink" title="6 输入/输出系统"></a>6 输入/输出系统</h2><h3 id="6-1-I-O设备及控制"><a href="#6-1-I-O设备及控制" class="headerlink" title="6.1 I/O设备及控制"></a>6.1 I/O设备及控制</h3><p>I/O设备管理具体包括：</p><ul><li>逻辑I/O：完成设备无关的操作，如设备分配、设备回收、数据准备等。</li><li>设备驱动程序：负责对设备控制器进行控制（通过读写其中的寄存器）。</li><li>中断服务程序：设备工作结束后负责向CPU发中断信号，中断服务程序完成相应处理。</li></ul><h4 id="6-1-1-I-O设备"><a href="#6-1-1-I-O设备" class="headerlink" title="6.1.1 I/O设备"></a>6.1.1 I/O设备</h4><p>按数据组织分类：</p><ul><li>块设备：以数据块为单位存储、传输信息。传输速率较高、可寻址（随机读写）。</li><li>字符设备：以字符为单位存储、传输信息。传输速率低、不可寻址。</li></ul><p>按用途分类：</p><ul><li>存储设备：磁盘、磁带；</li><li>传输设备：网卡、Modem；</li><li>人机交互设备：显示器、键盘、鼠标。</li></ul><p>从资源分配角度：</p><ul><li>独占设备：如打印机，磁带机</li><li>共享设备：如硬盘</li><li>虚设备</li></ul><h4 id="6-1-2-I-O控制技术（比较异同）"><a href="#6-1-2-I-O控制技术（比较异同）" class="headerlink" title="6.1.2 I/O控制技术（比较异同）"></a>6.1.2 I/O控制技术（比较异同）</h4><ul><li><p>程序控制/轮询/查询方式IO：由CPU代表进程向I/O模块发出指令，然后进入忙等状态，直到操作完成之后进程才能够继续执行。</p></li><li><p>中断驱动：当I/O操作结束后由设备控制器主动地来通知设备驱动程序，而不是依靠设备驱动程序不断地去轮询看看设备的状态。</p></li><li><p>直接内存访问（DMA）：由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604220717103.png" alt="image-20240604220717103"></p></li><li><p>通道技术（Channel）：与DMA原理几乎一样。通道是一个特殊功能的处理器，它有自己的指令和程序专门负责数据输入输出的传输控制。CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能。这样，通道与CPU分时使用内存，实现了CPU内部运算与I/O设备的并行工作。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604220740772.png" alt="image-20240604220740772"></p></li></ul><h4 id="6-1-3-I-O软件的组成与分层设计"><a href="#6-1-3-I-O软件的组成与分层设计" class="headerlink" title="6.1.3 I/O软件的组成与分层设计"></a>6.1.3 I/O软件的组成与分层设计</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604220829683.png" alt="image-20240604220829683"></p><h4 id="6-1-4-SPOOLing技术-假脱机技术"><a href="#6-1-4-SPOOLing技术-假脱机技术" class="headerlink" title="6.1.4 SPOOLing技术/假脱机技术"></a>6.1.4 SPOOLing技术/假脱机技术</h4><p>可把独享设备转变成具有共享特征的虚拟设备，从而提高设备利用率。</p><p>组成：</p><ul><li>输入井和输出井</li><li>输入缓冲区和输出缓冲区</li><li>输入进程$SP<em>{i}$和输出进程$SP</em>{o}$</li></ul><p>特点：</p><ul><li>高速虚拟I/O操作</li><li>实现对独享设备的共享</li></ul><h3 id="6-2-缓冲区的管理"><a href="#6-2-缓冲区的管理" class="headerlink" title="6.2 缓冲区的管理"></a>6.2 缓冲区的管理</h3><h4 id="6-2-1-缓冲区作用？"><a href="#6-2-1-缓冲区作用？" class="headerlink" title="6.2.1 缓冲区作用？"></a>6.2.1 缓冲区作用？</h4><p>可提高外设利用率。</p><p>原因：</p><ul><li>匹配CPU与外设的不同处理速度。</li><li>减少对CPU的中断次数。</li><li>提高CPU和I/O设备之间的并行性。</li></ul><blockquote><p>设从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为C。</p></blockquote><h4 id="6-2-2-单缓冲区"><a href="#6-2-2-单缓冲区" class="headerlink" title="6.2.2 单缓冲区"></a>6.2.2 单缓冲区</h4><p>由于T和C是可并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之则为M+C。处理时间表示为$Max(C,T)+M$。</p><h4 id="6-2-3-双缓冲区"><a href="#6-2-3-双缓冲区" class="headerlink" title="6.2.3 双缓冲区"></a>6.2.3 双缓冲区</h4><p>在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程(如下图)。接着由 CPU 对数据进行计算。在双缓冲时，系统处理一块数据的时间可以粗略地认为是$Max(C，T)$。如果 C<T，可使块设备连续输入；如果 C>T，则可使 CPU 不必等待设备输入。</p><h4 id="6-2-4-环形缓冲区"><a href="#6-2-4-环形缓冲区" class="headerlink" title="6.2.4 环形缓冲区"></a>6.2.4 环形缓冲区</h4><p>对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用，输入进程不断向空缓冲去输入数据，而计算进程则从中提取数据进行计算。</p><p><strong>循环缓冲区的组成如下</strong></p><p>• 多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为三种类型，用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的工作缓冲区C。</p><p>• 多个指针，作为输入的缓冲区可设置三个指针，用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti、以及用于指示计算进程正在使用的缓冲区C的指针Current</p><h4 id="6-2-5-缓冲池"><a href="#6-2-5-缓冲池" class="headerlink" title="6.2.5 缓冲池"></a>6.2.5 缓冲池</h4><p>上述仅使用于某特定的I/O进程和计算进程，因而它们属于专用缓冲。</p><p>当系统较大时，将会有许多这样的循环缓冲，将消耗大量内存空间且利用率不高。</p><p>共用缓冲池，包含三种类型的缓冲区：</p><ul><li>空缓冲区</li><li>装满输入数据的缓冲区</li><li>装满输出数据的缓冲区</li></ul><h3 id="6-3-I-O管理软件"><a href="#6-3-I-O管理软件" class="headerlink" title="6.3 I/O管理软件"></a>6.3 I/O管理软件</h3><h2 id="7-磁盘存储管理"><a href="#7-磁盘存储管理" class="headerlink" title="7 磁盘存储管理"></a>7 磁盘存储管理</h2><h4 id="7-1-磁盘的工作原理"><a href="#7-1-磁盘的工作原理" class="headerlink" title="7.1 磁盘的工作原理"></a>7.1 磁盘的工作原理</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604225321280.png" alt="image-20240604225321280"></p><h4 id="7-2-磁盘空间的管理"><a href="#7-2-磁盘空间的管理" class="headerlink" title="7.2 磁盘空间的管理"></a>7.2 磁盘空间的管理</h4><p>– 空闲表、空闲链表、位示图、成组链接</p><h4 id="7-3-磁盘访问时间"><a href="#7-3-磁盘访问时间" class="headerlink" title="7.3 磁盘访问时间"></a>7.3 磁盘访问时间</h4><p>– 寻道时间 + 旋转延迟时间 + 传输时间</p><p>$T_a=T_s＋1/(2r)＋ b/(rN)$</p><p>$r:转速(r/s)$, $b:每次所读/写的字节数$, $N:磁道上的字节数$</p><h4 id="7-4-磁盘调度算法"><a href="#7-4-磁盘调度算法" class="headerlink" title="7.4 磁盘调度算法"></a>7.4 磁盘调度算法</h4><h5 id="先来先服务FCFS-1"><a href="#先来先服务FCFS-1" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230054339.png" alt="image-20240604230054339"></p><h5 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230112935.png" alt="image-20240604230112935"></p><h5 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230150696.png" alt="image-20240604230150696"></p><h5 id="循环扫描算法C-SCAN"><a href="#循环扫描算法C-SCAN" class="headerlink" title="循环扫描算法C-SCAN"></a>循环扫描算法C-SCAN</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230214184.png" alt="image-20240604230214184"></p><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>FCFS</strong></td><td>公平、简单</td><td>平均寻道距离大，仅应用在磁盘I/O较少的场合</td></tr><tr><td><strong>SSTF</strong></td><td>性能比FCFS好</td><td>不能保证平均寻道时间最短，可能出现“饥饿”现象</td></tr><tr><td><strong>SCAN</strong></td><td>寻道性能好，可能避免“饥饿”现象</td><td>不利于远离磁头一端的访问请求</td></tr><tr><td><strong>C-SCAN</strong></td><td>消除了对两端磁道请求的不公平</td><td>-</td></tr></tbody></table></div><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230555816.png" alt="image-20240604230555816"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230613371.png" alt="image-20240604230613371"></p><h4 id="7-5-提高I-O速度的主要途径"><a href="#7-5-提高I-O速度的主要途径" class="headerlink" title="7.5 提高I/O速度的主要途径"></a>7.5 提高I/O速度的主要途径</h4><ul><li>选择性能好的磁盘</li><li>并行化</li><li>采用适当的调度算法</li><li>设置磁盘高速缓冲区<ol><li>缓存形式<ul><li>独立缓存（固定大小）</li><li>以虚拟内存为缓存（弹性大小）</li></ul></li><li>数据交付<ul><li>直接交付（copy开销）</li><li>指针交付（内存管理复杂）</li></ul></li><li>置换算法：LRU</li><li>周期性写回：disk cache-&gt;磁盘</li></ol></li></ul><h4 id="7-6-廉价冗余磁盘阵列-RAID"><a href="#7-6-廉价冗余磁盘阵列-RAID" class="headerlink" title="7.6 廉价冗余磁盘阵列: RAID"></a>7.6 廉价冗余磁盘阵列: RAID</h4><ul><li>利用冗余技术提高可靠性</li><li>利用并行提高性能</li></ul><p>定义：把多种独立的硬盘（物理硬盘）按照不同方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据冗余的技术。</p><p>组成磁盘阵列的不同方式：RAID级别。</p><p>数据冗余的功能是在用户数据一旦发生损坏后，利用冗余信息可以使损失数据得以恢复，从而保障了用户数据的安全性。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>成本低，功耗小，传输速率高</li></ul><p>• RAID比起传统的大直径磁盘驱动器来，在同样的容量下，价格要低许多。</p><p>• RAID让很多磁盘驱动器==并行传输数据==，比单个磁盘驱动器提高几倍、几十倍甚至上百倍的速率。有效缓解了快速的CPU与慢速的磁盘之间的矛盾</p><ul><li>可提供容错功能</li></ul><p>• 普通磁盘驱动器只能通过CRC(循环冗余校验)码提供简单的容错，RAID建立在每个磁盘驱动器的硬件容错功能之上，可提供==更高的可靠性==。</p><h5 id="RAID分级"><a href="#RAID分级" class="headerlink" title="RAID分级"></a>RAID分级</h5><p>主流的RAID有7个级别。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604232954270.png" alt="image-20240604232954270"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604233050985.png" alt="image-20240604233050985"></p><h2 id="8-文件系统"><a href="#8-文件系统" class="headerlink" title="8 文件系统"></a>8 文件系统</h2><h3 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h3><h4 id="8-1-1-文件的概念"><a href="#8-1-1-文件的概念" class="headerlink" title="8.1.1 文件的概念"></a>8.1.1 文件的概念</h4><p>一组带标识的、在逻辑上有完整==意义==的==信息项==的序列。实际上是一组==字节序列==：一切皆文件。文件包括两部分：</p><ul><li>文件体：文件本身的内容；</li><li>文件说明：文件存储和管理的相关信息。</li></ul><h4 id="8-1-2-文件的形式"><a href="#8-1-2-文件的形式" class="headerlink" title="8.1.2 文件的形式"></a>8.1.2 文件的形式</h4><ul><li>以字节为单位的==流式结构==</li><li>==记录性文件==结构</li><li>==树形结构==</li></ul><h4 id="8-1-3-目录的概念"><a href="#8-1-3-目录的概念" class="headerlink" title="8.1.3 目录的概念"></a>8.1.3 目录的概念</h4><p>==由文件说明索引组成的用于文件检索的特殊文件==。内容主要是文件访问和控制的信息（不包括文件内容）。</p><h4 id="8-1-4-文件系统的功能"><a href="#8-1-4-文件系统的功能" class="headerlink" title="8.1.4 文件系统的功能"></a>8.1.4 文件系统的功能</h4><h3 id="8-2-目录的作用、内容、结构"><a href="#8-2-目录的作用、内容、结构" class="headerlink" title="8.2 目录的作用、内容、结构"></a>8.2 目录的作用、内容、结构</h3><p>根据用户给出的ASCII形式的文件名（路径名），迅速地定位到相应的文件控制块。</p><p>不同的系统采用不同的实现方法，一般分为两类：</p><p>§ 直接法：目录项＝文件名＋文件控制块（属性信息、在外存上的存放位置）。如MS-DOS/Windows；</p><p>§ 间接法：目录项＝文件名＋文件控制块的地址（索引号）。如Unix（inode）；</p><h3 id="8-3-文件系统实现技术"><a href="#8-3-文件系统实现技术" class="headerlink" title="8.3 文件系统实现技术"></a>8.3 文件系统实现技术</h3><h4 id="8-3-1-文件控制块"><a href="#8-3-1-文件控制块" class="headerlink" title="8.3.1 文件控制块"></a>8.3.1 文件控制块</h4><ul><li><p>基本信息</p><ul><li>文件名</li><li>物理位置</li><li>文件逻辑结构：有/无结构（记录文件，流式文件）</li><li>文件物理结构：如顺序，索引等</li></ul></li><li><p>访问控制信息</p><ul><li>文件所有者（属主）</li><li>访问权限</li></ul></li><li>使用信息<ul><li>创建时间，上一次修改时间，当前使用信息等。</li></ul></li></ul><h4 id="8-3-2-文件的逻辑结构：记录、流式"><a href="#8-3-2-文件的逻辑结构：记录、流式" class="headerlink" title="8.3.2 文件的逻辑结构：记录、流式"></a>8.3.2 文件的逻辑结构：记录、流式</h4><h4 id="8-3-3-文件的物理结构"><a href="#8-3-3-文件的物理结构" class="headerlink" title="8.3.3 文件的物理结构"></a>8.3.3 文件的物理结构</h4><h5 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h5><p>容易出现磁盘碎片，适合变化不大的文件</p><p>§ 优点：</p><p>§ 结构简单，实现容易，不需要额外的空间开销</p><p>§ 顺序存取和随机存取的效率高</p><p>§ 缺点：</p><p>§ 文件长度一经固定便不易改变；</p><p>§ 不利于文件的动态增加和修改；</p><h5 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h5><p>§ 优点：</p><p>§ 空间利用率高；能较好的利用外存空间；</p><p>§ 文件动态扩充和修改容易；</p><p>§ 顺序存取效率高；类似于存储管理中的页式</p><p>§ 缺点：</p><p>§ 随机存取效率太低，如果访问文件的最后的内容，实际</p><p>上是要访问整个文件。</p><p>§ 可靠性问题，如指针出错;</p><p>§ 链接指针占用一定的空间。</p><h5 id="索引文件：一级索引、多级索引"><a href="#索引文件：一级索引、多级索引" class="headerlink" title="索引文件：一级索引、多级索引"></a>索引文件：一级索引、多级索引</h5><p>§ 一个文件的信息存放在若干个不连续物理块中</p><p>§ 系统为每个文件建立一个专用数据结构：索引表，并将这些物理块的块号存放在该索引中。</p><p>§ 索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604234653755.png" alt="image-20240604234653755"></p><h3 id="8-4-文件的共享、保护、保密"><a href="#8-4-文件的共享、保护、保密" class="headerlink" title="8.4 文件的共享、保护、保密"></a>8.4 文件的共享、保护、保密</h3><h4 id="8-4-1-保护文件的方法"><a href="#8-4-1-保护文件的方法" class="headerlink" title="8.4.1 保护文件的方法"></a>8.4.1 保护文件的方法</h4><ul><li>建立副本<ol><li>优点：方法简单</li><li>缺点：设备费用和系统开销增大</li><li>适用于短小且极为重要的文件</li></ol></li><li>定时转储</li><li>规定文件的权限</li></ul><h4 id="8-4-2-性能问题"><a href="#8-4-2-性能问题" class="headerlink" title="8.4.2 性能问题"></a>8.4.2 性能问题</h4><p>§ 磁盘服务：速度成为系统性能的主要瓶颈之一。因此，在设计文件系统时应尽可能减少磁盘访问次数。</p><p>§ 提高文件系统性能的方法：目录项分解、当前目录、磁盘碎片整理、==块高速缓存==、磁盘调度、提前读取、合理分配磁盘空间、数据的优化分布、RAID技术等。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operate System</title>
      <link href="/2024/06/05/Operate-System-Term-View/"/>
      <url>/2024/06/05/Operate-System-Term-View/</url>
      
        <content type="html"><![CDATA[<h1 id="Operate-System"><a href="#Operate-System" class="headerlink" title="Operate System"></a>Operate System</h1><h2 id="0-试卷资源"><a href="#0-试卷资源" class="headerlink" title="0 试卷资源"></a>0 试卷资源</h2><p><a href="https://www.docin.com/p-4664837653.html" target="_blank" rel="noopener">模拟</a></p><h2 id="1-考纲"><a href="#1-考纲" class="headerlink" title="1 考纲"></a>1 考纲</h2><ul><li><p>了解操作系统<strong>各个组成部分</strong>的基本结构和原理</p></li><li><p><strong>掌握</strong>在<strong>进程管理</strong>、<strong>存储管理</strong>、<strong>设备管理</strong>、<strong>磁盘管理</strong>及<strong>文件管理</strong>等涉及的概念和相关算法</p></li></ul><h2 id="2-引论"><a href="#2-引论" class="headerlink" title="2 引论"></a>2 引论</h2><h3 id="2-1-冯·诺伊曼体系结构"><a href="#2-1-冯·诺伊曼体系结构" class="headerlink" title="2.1 冯·诺伊曼体系结构"></a>2.1 冯·诺伊曼体系结构</h3><p>==存储程序式，集中顺序过程控制==</p><h4 id="2-1-1-组成"><a href="#2-1-1-组成" class="headerlink" title="2.1.1 组成"></a>2.1.1 组成</h4><ul><li>中央处理单元</li><li>存储器</li><li>输入输出</li></ul><h4 id="2-1-2-架构局限"><a href="#2-1-2-架构局限" class="headerlink" title="2.1.2 架构局限"></a>2.1.2 架构局限</h4><p>§ CPU与内存的交互引起的内存墙问题</p><p>§ 数据与指令不区分，指令等数据或数据等指令</p><p>§ 串行顺序处理，缺乏数据并行能力</p><h3 id="2-2-操作系统的发展变化"><a href="#2-2-操作系统的发展变化" class="headerlink" title="2.2 操作系统的发展变化"></a>2.2 操作系统的发展变化</h3><h4 id="2-2-1-批处理系统"><a href="#2-2-1-批处理系统" class="headerlink" title="2.2.1 批处理系统"></a>2.2.1 批处理系统</h4><h5 id="2-2-1-1-定义"><a href="#2-2-1-1-定义" class="headerlink" title="2.2.1.1 定义"></a>2.2.1.1 定义</h5><p>加载在计算机上的一个系统软件，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。</p><h5 id="2-2-1-2-分类"><a href="#2-2-1-2-分类" class="headerlink" title="2.2.1.2 分类"></a>2.2.1.2 分类</h5><ul><li><p>联机批处理系统：即作业的输入/输出由CPU来处理。出现“忙等”。</p></li><li><p>脱机批处理系统：为克服与缓解高速主机与慢速外设的矛盾，提高CPU的利用率，又引入了脱机批处理系统，即输入/输出脱离主机控制</p></li></ul><h4 id="2-2-2-多道程序系统"><a href="#2-2-2-多道程序系统" class="headerlink" title="2.2.2 多道程序系统"></a>2.2.2 多道程序系统</h4><p>不仅使CPU得到充分利用，同时也改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（即单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p><p>标志着操作系统渐趋成熟的阶段，先后出现了作业调度管理、处理机管理、存储器管理、外部设备管理、文件系统管理等功能。</p><p><strong>特点：</strong></p><ol><li>多道</li><li>宏观上并行</li><li>微观上串行</li></ol><p><strong>优点：</strong></p><ul><li>系统吞吐量大</li><li>资源利用率高</li></ul><p><strong>缺点：</strong></p><ul><li>平均周转时间长</li><li>不能提供交互能力</li></ul><h4 id="2-2-3-分时系统"><a href="#2-2-3-分时系统" class="headerlink" title="2.2.3 分时系统"></a>2.2.3 分时系统</h4><h5 id="2-2-3-1-定义"><a href="#2-2-3-1-定义" class="headerlink" title="2.2.3.1 定义"></a>2.2.3.1 定义</h5><p>多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源。</p><h5 id="2-2-3-2-特点"><a href="#2-2-3-2-特点" class="headerlink" title="2.2.3.2 特点"></a>2.2.3.2 特点</h5><ul><li>多路性</li><li>独立性：用户相互不打扰</li><li>及时性：响应时间</li><li>交互性：人机对话</li></ul><h4 id="2-2-4-实时、网络、分布式"><a href="#2-2-4-实时、网络、分布式" class="headerlink" title="2.2.4 实时、网络、分布式"></a>2.2.4 实时、网络、分布式</h4><h5 id="2-2-4-1-实时"><a href="#2-2-4-1-实时" class="headerlink" title="2.2.4.1 实时"></a>2.2.4.1 实时</h5><p>• 及时响应</p><p>• 高可靠性和安全性</p><p>• 系统的整体性强</p><p>• 交互会话活动较弱</p><p>• 专用系统</p><p>• 种类：实时信息处理、实时控制</p><h5 id="2-2-4-2-网络"><a href="#2-2-4-2-网络" class="headerlink" title="2.2.4.2 网络"></a>2.2.4.2 网络</h5><p>==联网==功能，资源的==远程访问==</p><h5 id="2-2-4-3-分布式"><a href="#2-2-4-3-分布式" class="headerlink" title="2.2.4.3 分布式"></a>2.2.4.3 分布式</h5><p>定义：在整个系统中有一个==全局==的操作系统</p><p>多台机器统一管理形成==单一系统==，相比网络，对用户和应用高度==透明==。具有多级合作和健壮性。</p><ul><li>==数据==透明</li><li>==执行==透明</li><li>==保护==透明</li></ul><h3 id="2-3-操作系统的主要功能"><a href="#2-3-操作系统的主要功能" class="headerlink" title="2.3 操作系统的主要功能"></a>2.3 操作系统的主要功能</h3><p>• 提供==解决各种冲突==（资源竞争引起）的策略</p><p>– 处理机调度、进程调度、内存分配、设备分配等</p><p>• ==协调并发活动==的关系（提供流程控制和避免运行</p><p>结果不确定性）</p><p>– 进程之间的通信，同步与互斥</p><p>• ==保证数据的一致性==</p><p>– 读写数据时，数据结构中的内容是否真实地记录了数</p><p>据的实际情况</p><p>– 在分布式处理时的共享数据的不同副本是否一致</p><p>• 实现==数据的存取控制==</p><p>– 共享程度、隐私程度、安全程度的控制</p><h4 id="2-3-1-进程管理（处理机分配）"><a href="#2-3-1-进程管理（处理机分配）" class="headerlink" title="2.3.1 进程管理（处理机分配）"></a>2.3.1 进程管理（处理机分配）</h4><h5 id="2-3-1-1-核心任务：如何分配CPU时间"><a href="#2-3-1-1-核心任务：如何分配CPU时间" class="headerlink" title="2.3.1.1 核心任务：如何分配CPU时间"></a>2.3.1.1 核心任务：如何分配CPU时间</h5><ul><li>进程管理<ul><li>进程的调度：创建、挂起、激活</li><li>进程间的通信：同步、互斥、死锁</li></ul></li><li>线程管理</li></ul><h5 id="2-3-1-2-主要功能"><a href="#2-3-1-2-主要功能" class="headerlink" title="2.3.1.2 主要功能"></a>2.3.1.2 主要功能</h5><ul><li>公平分配</li><li>保证非阻塞</li><li>按优先级分配</li></ul><h4 id="2-3-2-存储管理"><a href="#2-3-2-存储管理" class="headerlink" title="2.3.2 存储管理"></a>2.3.2 存储管理</h4><h5 id="2-3-2-1-核心任务"><a href="#2-3-2-1-核心任务" class="headerlink" title="2.3.2.1 核心任务"></a>2.3.2.1 核心任务</h5><p>管理缓存、主存、磁盘等所形成的多级存储架构，为多道程序的并发提供良好的环境</p><h5 id="2-3-2-2-主要功能"><a href="#2-3-2-2-主要功能" class="headerlink" title="2.3.2.2 主要功能"></a>2.3.2.2 主要功能</h5><ul><li>内存分配和存储无关性</li><li>内存保护：互不干扰</li><li>内存扩充：虚拟存储器</li></ul><h4 id="2-3-3-设备管理（包括磁盘管理）"><a href="#2-3-3-设备管理（包括磁盘管理）" class="headerlink" title="2.3.3 设备管理（包括磁盘管理）"></a>2.3.3 设备管理（包括磁盘管理）</h4><h5 id="2-3-3-1-核心任务"><a href="#2-3-3-1-核心任务" class="headerlink" title="2.3.3.1 核心任务"></a>2.3.3.1 核心任务</h5><p>管理输入/输出设备，屏蔽差异性，提供并发访问</p><h5 id="2-3-3-2-主要功能"><a href="#2-3-3-2-主要功能" class="headerlink" title="2.3.3.2 主要功能"></a>2.3.3.2 主要功能</h5><ul><li><p>设备无关性：逻辑设备-&gt;物理设备</p></li><li><p>设备分配：独享、共享和虚拟</p></li><li><p>设备的传输控制：<strong>中断</strong>、<strong>通道</strong></p></li></ul><h4 id="2-3-4-文件系统"><a href="#2-3-4-文件系统" class="headerlink" title="2.3.4 文件系统"></a>2.3.4 文件系统</h4><h5 id="2-3-4-1-核心任务"><a href="#2-3-4-1-核心任务" class="headerlink" title="2.3.4.1 核心任务"></a>2.3.4.1 核心任务</h5><p>将磁盘变成一个很容易使用的存储媒介提供给用户使用</p><h5 id="2-3-4-2-主要功能"><a href="#2-3-4-2-主要功能" class="headerlink" title="2.3.4.2 主要功能"></a>2.3.4.2 主要功能</h5><ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件读写管理</li><li>文件保护</li><li>向用户提供接口</li></ul><h4 id="2-3-5-接口管理"><a href="#2-3-5-接口管理" class="headerlink" title="2.3.5 接口管理"></a>2.3.5 接口管理</h4><h5 id="2-3-5-1-程序接口"><a href="#2-3-5-1-程序接口" class="headerlink" title="2.3.5.1 程序接口"></a>2.3.5.1 程序接口</h5><p>系统调用</p><h5 id="2-3-5-2-用户接口"><a href="#2-3-5-2-用户接口" class="headerlink" title="2.3.5.2 用户接口"></a>2.3.5.2 用户接口</h5><p>联机用户接口</p><p>脱机用户接口</p><p>图形用户接口</p><h3 id="2-4-现代操作系统的基本特征"><a href="#2-4-现代操作系统的基本特征" class="headerlink" title="2.4 现代操作系统的基本特征"></a>2.4 现代操作系统的基本特征</h3><ul><li><p>==并发==执行</p></li><li><p>资源==共享==</p></li><li><p>==虚拟化==管理：CPU, 存储器</p></li><li><p>==异步性==（不确定性事件的处理）</p></li></ul><h3 id="2-5-操作系统的工作模式"><a href="#2-5-操作系统的工作模式" class="headerlink" title="2.5 操作系统的工作模式"></a>2.5 操作系统的工作模式</h3><h4 id="2-5-1-内核态-管态"><a href="#2-5-1-内核态-管态" class="headerlink" title="2.5.1 内核态/管态"></a>2.5.1 内核态/管态</h4><p>运行操作系统程序</p><h4 id="2-5-2-用户态-目态"><a href="#2-5-2-用户态-目态" class="headerlink" title="2.5.2 用户态/目态"></a>2.5.2 用户态/目态</h4><p>运行用户程序</p><h4 id="2-5-3-切换过程？"><a href="#2-5-3-切换过程？" class="headerlink" title="2.5.3 切换过程？"></a>2.5.3 切换过程？</h4><p>内核与应用使用不同的页表。用户态无法直接寻址内核空间的数据。因此需要切换。</p><p>用户态—&gt;内核态：中断/异常/陷入机制</p><p>内核态—&gt;用户态：设置程序状态字PSW（MIPS的CP0寄存器）</p><h4 id="2-5-4-几个术语"><a href="#2-5-4-几个术语" class="headerlink" title="2.5.4 几个术语"></a>2.5.4 几个术语</h4><h5 id="2-5-4-1-特权指令-保护指令"><a href="#2-5-4-1-特权指令-保护指令" class="headerlink" title="2.5.4.1 特权指令/保护指令"></a>2.5.4.1 特权指令/保护指令</h5><p>只能由操作系统使用、用户程序不能使用的指令</p><h5 id="2-5-4-2-异常：中断、陷入（作用、区别？）（系统调用过程）"><a href="#2-5-4-2-异常：中断、陷入（作用、区别？）（系统调用过程）" class="headerlink" title="2.5.4.2 异常：中断、陷入（作用、区别？）（系统调用过程）"></a>2.5.4.2 异常：中断、陷入（作用、区别？）（系统调用过程）</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603141523948.png" alt="image-20240603141523948"></p><h5 id="2-5-4-3-系统调用的概念"><a href="#2-5-4-3-系统调用的概念" class="headerlink" title="2.5.4.3 系统调用的概念"></a>2.5.4.3 系统调用的概念</h5><p>系统调用提供用户程序与操作系统之间的接口，唯一接口使CPU状态从用户态陷入内核态</p><h4 id="2-5-5-系统调用和函数调用的区别"><a href="#2-5-5-系统调用和函数调用的区别" class="headerlink" title="2.5.5 系统调用和函数调用的区别"></a>2.5.5 系统调用和函数调用的区别</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603144212316.png" alt="image-20240603144212316"></p><h5 id="2-5-5-1-用户态程序如何访问系统功能，描述过程，如何切换入内核态执行"><a href="#2-5-5-1-用户态程序如何访问系统功能，描述过程，如何切换入内核态执行" class="headerlink" title="2.5.5.1 用户态程序如何访问系统功能，描述过程，如何切换入内核态执行"></a>2.5.5.1 用户态程序如何访问系统功能，描述过程，如何切换入内核态执行</h5><ol><li>CPU执行<code>int 0x2e</code>，CPU运行状态切换为系统态</li><li><p>当前进程使用的堆栈，从用户态切换到系统态。堆栈原先的内容（用户态），以及用户空间的堆栈指针，被压入系统空间堆栈。</p></li><li><p>从中断向量表中(<code>InterruptDescriptor Table</code>)以<code>0x2e</code>为中断向量，开始执行系统空间中的程序。</p></li><li><p>程序执行后，通过<code>iret</code>(中断返回)指令实现上述过程的逆过程</p></li></ol><blockquote><p>当CPU执行到特殊的陷入指令时</p><p>§ 中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序</p><p>§ 系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数</p><p>§ 执行系统调用例程</p><p>§ 恢复现场，返回用户程序</p></blockquote><h3 id="2-6-操作系统结构"><a href="#2-6-操作系统结构" class="headerlink" title="2.6 操作系统结构"></a>2.6 操作系统结构</h3><h4 id="2-6-1-计算机体系结构中的接口"><a href="#2-6-1-计算机体系结构中的接口" class="headerlink" title="2.6.1 计算机体系结构中的接口"></a>2.6.1 计算机体系结构中的接口</h4><ul><li>UI</li><li>API: API 定义了源代码和库之间的接口，因此同样的代码可以在支持这个 API 的任何系统中<strong>编译</strong> 。</li><li>ABI: 应用程序二进制接口, ABI 允许编译好的目标代码在使用兼容 ABI 的系统中无需改动就能<strong>运行</strong>。(2024期中三3)</li><li>ISA: ISA充当软件和硬件之间的接口，为ISA编写的软件可以在同一ISA的不同实现上运行。这使得可以轻松实现不同代计算机之间的二进制兼容性以及计算机家族的发展。</li></ul><p><img src="D:\BUAA\STAR\OS_LAB\img\接口.png" alt=""></p><h4 id="2-6-2-什么是操作系统内核？如何进入？"><a href="#2-6-2-什么是操作系统内核？如何进入？" class="headerlink" title="2.6.2 什么是操作系统内核？如何进入？"></a>2.6.2 什么是操作系统内核？如何进入？</h4><h4 id="2-6-3-微内核、整体内核（宏内核）"><a href="#2-6-3-微内核、整体内核（宏内核）" class="headerlink" title="2.6.3 微内核、整体内核（宏内核）"></a>2.6.3 微内核、整体内核（宏内核）</h4><h5 id="2-6-3-1-辨析"><a href="#2-6-3-1-辨析" class="headerlink" title="2.6.3.1 辨析"></a>2.6.3.1 辨析</h5><p>宏内核：<strong>整个系统分为内核与应用两层</strong></p><p>• 内核：运行在特权级，集中控制所有计算资源</p><p>• 应用：运行在非特权级，受内核管理，使用内核服务</p><p>微内核：内核中只包括中断处理、进程通信（IPC）、基本调度等。文件系统、网络功能、内存管理、设备管理等作为服务在微内核上运行。<strong>设计原则：最小化内核功能</strong></p><p>• 将操作系统功能移到用户态，称为服务（Server）</p><p>• 在用户模块之间，使用消息传递机制通信</p><h5 id="2-6-3-2-优缺点"><a href="#2-6-3-2-优缺点" class="headerlink" title="2.6.3.2 优缺点"></a>2.6.3.2 优缺点</h5><p>对<strong>宏内核</strong>而言</p><ul><li>优点：宏内核拥有丰富的沉淀和积累<ul><li>拥有巨大的统一的社区和生态</li><li>针对不同场景优化了30年</li></ul></li><li>缺点：<ul><li>安全性与可靠性问题：模块之间没有很强的隔离机制</li><li>实时性支持：系统太复杂导致无法做最坏情况时延分析</li><li>系统过于庞大而阻碍了创新：Linux代码行数已经过2千万</li></ul></li></ul><p>对<strong>微内核</strong>而言</p><ul><li>优点：内核易于实现、可移植性好、配置灵活、适应分布式环境（本地内核与远程内核对服务提供同样支持）、安全性高</li><li>缺点：速度较慢。（扩大内核减少切换；减少内核提高其他优点）</li></ul><blockquote><p>完整版：</p><p>§ <strong>优点</strong></p><p>• 易于扩展：直接添加一个用户进程即可为操作系统增加服务</p><p>• 易于移植：大部分模块与底层硬件无关</p><p>• 更加可靠：在内核模式运行的代码量大大减少</p><p>• 更加安全：即使存在漏洞，服务与服务之间存在进程粒度隔离</p><p>• 更加健壮：单个模块出现问题不会影响到系统整体</p><p>§ <strong>缺点</strong></p><p>• 性能较差：内核中的模块交互由函数调用变成了进程间通信</p><p>• 生态欠缺：尚未形成像Linux一样具有广泛开发者的社区</p><p>• 重用问题：重用宏内核操作系统提供兼容性，带来新问题</p></blockquote><h2 id="3-操作系统引导"><a href="#3-操作系统引导" class="headerlink" title="3 操作系统引导"></a>3 操作系统引导</h2><h3 id="3-1-OS分阶段引导过程"><a href="#3-1-OS分阶段引导过程" class="headerlink" title="3.1 OS分阶段引导过程"></a>3.1 OS分阶段引导过程</h3><ul><li><p>CPU通电启动或者Reset时，CPU从一个预定义的内存位置开始执行bootloader</p></li><li><p>bootloader程序一般存储于ROM只读存储器，因为RAM在系统启动时处于未知状态，而ROM它不需要初始化，也不容易被计算机病毒感染</p><blockquote><p>Bootloader需要正确地找到内核并加载执行，大部分分为stage1和stage2两个部分</p><p>§ <strong>Stage 1</strong></p><p>• 依赖于CPU体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现</p><p>• 需要初始化硬件设备，包括 watchdog timer、中断、时钟、内存等</p><p>• bootloader 程序直接从非易失存储器上（比如 ROM 或 FLASH）加载，为加载 stage2 准备 RAM 空间</p><p>§ <strong>Stage 2</strong></p><p>• 通常用C语言来实现，可实现复杂功能，更好的可读性和移植性</p><p>• 初始化这一阶段需要使用的硬件设备以及其他功能</p><p>• 将内核镜像从存储器读到 RAM 中，并为内核设置启动参数</p><p>• 将 CPU 指令寄存器的内容设置为内核入口函数的地址，即可将控制权从 bootloader 转交给操作系统内核</p></blockquote></li><li><p>通过bootloader，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备</p></li></ul><h3 id="3-2-各个阶段的职责"><a href="#3-2-各个阶段的职责" class="headerlink" title="3.2 各个阶段的职责"></a>3.2 各个阶段的职责</h3><ol><li><p>加载BIOS。BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。</p><blockquote><p>UEFI和BIOS的比较</p><p>二者显著的区别是：</p><p>§ EFI是用模块化，C语言风格的参数堆栈传递方式，动态链接的形式构建的系统，较BIOS而言更易于实现，容错和纠错特性更强，缩短了系统研发的时间。</p><p>§ 它运行于32位或64位模式，乃至未来增强的处理器模式下，突破传统BIOS的16位代码的寻址能力，达到处理器的最大寻址。</p></blockquote></li><li><p>读取MBR。硬盘上第0磁头第0磁道第1个扇区被称为MBR，即主引导记录，它的大小是512字节，存放了预启动信息、分区表信息。</p><ul><li>由于MBR的限制 只能有4个主分区，系统必须装在主分区上面。</li><li>硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。</li><li>一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干个。</li><li>主分区只能有一个是激活的（active），其余为inactive。</li></ul><blockquote><p>MBR组成：</p><p>§ MBR主引导记录包含两部分的内容，前446字节为启动代码及数据</p><p>§ 之后则是分区表（DPT, Disk Partition Table），分区表由四个分区项组成，每个分区项数据为16字节，记录了启动时需要的分区参数。这64个字节分布在MBR的第447-510字节</p><p>§ 后面紧接着两个字节AA和55被称为幻数, BOIS读取MBR的时候总是检查最后是不是有这两个幻数，如果没有就被认为是一个没有被分区的硬盘。</p></blockquote></li><li><p><strong>Boot Loader</strong></p><p>§ LILO 没有交互式命令界面，而 GRUB 拥有。</p><p>§ LILO 不支持网络引导，而 GRUB 支持。</p><p>§ LILO 将关于可以引导的操作系统位置的信息物理上存储在 MBR 中。如果修改了 LILO 配置文件，必须将 LILO 第一阶段引导加载程序重写到 MBR。错误配置的 MBR 可能会让系统无法引导。</p><p>§ 使用 GRUB，如果配置文件配置错误，则只是默认转到 GRUB 命令行界面。</p></li></ol><h3 id="3-3-各个阶段引导程序的存储与装载过程"><a href="#3-3-各个阶段引导程序的存储与装载过程" class="headerlink" title="3.3 各个阶段引导程序的存储与装载过程"></a>3.3 各个阶段引导程序的存储与装载过程</h3><p>程序的链接与装载：<strong>编译</strong>-<strong>链接</strong>-<strong>装载</strong>-<strong>执行</strong></p><p>程序一般由3个段组成，除此之外还需构建一个栈，一个堆：</p><ul><li>bss段：未初始化的全局变量，静态内存分配。<strong>不</strong>在可执行文件中，由系统初始化。</li><li>data段：已初始化的全局变量，static声明的变量，静态内存分配。在可执行文件中。</li><li>text段：用来存放程序执行代码的一块内存区域，可能包含一些只读的常数变量，例如字符串常量。在可执行文件中。</li><li>栈（stack）：存放、交换临时数据的内存区。存放程序局部变量（<strong>但不</strong>包括static声明的变量，static意味着在数据段中存放变量）</li><li>堆（heap）：动态分配的内存段，当进程调用malloc等函数，新分配的内存就被动态添加到堆上。</li></ul><h4 id="3-3-1-程序的装载细节"><a href="#3-3-1-程序的装载细节" class="headerlink" title="3.3.1 程序的装载细节"></a>3.3.1 程序的装载细节</h4><p>一个segment在文件中的大小是<strong>小于等于</strong>其在内存中的大小。如果在文件中的大小小于在内存应有的大小，载入时会<strong>补零</strong>直至应有的大小。</p><h3 id="3-4-简述Linux内核在x86平台上的加载过程"><a href="#3-4-简述Linux内核在x86平台上的加载过程" class="headerlink" title="3.4.简述Linux内核在x86平台上的加载过程"></a>3.4.简述Linux内核在x86平台上的加载过程</h3><h2 id="4-存储管理"><a href="#4-存储管理" class="headerlink" title="4 存储管理"></a>4 存储管理</h2><h3 id="4-1-存储管理的功能"><a href="#4-1-存储管理的功能" class="headerlink" title="4.1 存储管理的功能"></a>4.1 存储管理的功能</h3><h4 id="4-1-1-内存的分配与回收"><a href="#4-1-1-内存的分配与回收" class="headerlink" title="4.1.1 内存的分配与回收"></a>4.1.1 内存的分配与回收</h4><h4 id="4-1-2-存储保护"><a href="#4-1-2-存储保护" class="headerlink" title="4.1.2 存储保护"></a>4.1.2 存储保护</h4><h4 id="4-1-3-地址转换"><a href="#4-1-3-地址转换" class="headerlink" title="4.1.3 地址转换"></a>4.1.3 地址转换</h4><h4 id="4-1-4-静态重定位"><a href="#4-1-4-静态重定位" class="headerlink" title="4.1.4 静态重定位"></a>4.1.4 静态重定位</h4><p>• 当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换</p><p>• 一般可以由软件完成</p><h4 id="4-1-5-动态重定位"><a href="#4-1-5-动态重定位" class="headerlink" title="4.1.5 动态重定位"></a>4.1.5 动态重定位</h4><p>• 在进程执行过程中进行地址变换，<strong>即逐条指令执行时完成地址转换</strong></p><p>• 需要硬件部件支持</p><h4 id="4-1-6-存储共享"><a href="#4-1-6-存储共享" class="headerlink" title="4.1.6 存储共享"></a>4.1.6 存储共享</h4><h4 id="4-1-7-扩充内存容量"><a href="#4-1-7-扩充内存容量" class="headerlink" title="4.1.7 扩充内存容量"></a>4.1.7 扩充内存容量</h4><h3 id="4-2-分区存储管理"><a href="#4-2-分区存储管理" class="headerlink" title="4.2 分区存储管理"></a>4.2 分区存储管理</h3><h4 id="4-2-1-固定分区"><a href="#4-2-1-固定分区" class="headerlink" title="4.2.1 固定分区"></a>4.2.1 固定分区</h4><h5 id="4-2-1-1-基本思想"><a href="#4-2-1-1-基本思想" class="headerlink" title="4.2.1.1 基本思想"></a>4.2.1.1 基本思想</h5><p>采用的数据结构：分区表记录分区的大小和使用情况</p><h5 id="4-2-1-2-优缺点"><a href="#4-2-1-2-优缺点" class="headerlink" title="4.2.1.2 优缺点"></a>4.2.1.2 优缺点</h5><p><strong>§ 优点</strong></p><p>• 易于实现，开销小</p><p><strong>§ 缺点</strong></p><p>• 内部碎片，造成空间浪费</p><blockquote><h5 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h5><h6 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h6><p>分配大小大于实际使用</p><h6 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h6><p>空闲的但不连续，无法被使用，==外部碎片才是造成内存系统性能下降的主要原因==。</p><h6 id="如何消除内部碎片和外部碎片"><a href="#如何消除内部碎片和外部碎片" class="headerlink" title="如何消除内部碎片和外部碎片"></a>如何消除内部碎片和外部碎片</h6><ul><li><p>伙伴系统</p><p>介于固定分区与可变分区之间，其大小均为$2^{k}$。</p></li><li><p>紧凑技术</p><p>通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为紧凑（拼接或紧缩） 。</p><p>==实现支撑==：动态重定位。</p></li><li><p>段/页式内存管理</p></li></ul></blockquote><p>• 分区总数固定，限制了并发执行的程序数目</p><h4 id="4-2-2-可变分区"><a href="#4-2-2-可变分区" class="headerlink" title="4.2.2 可变分区"></a>4.2.2 可变分区</h4><h5 id="4-2-2-1-基本思想"><a href="#4-2-2-1-基本思想" class="headerlink" title="4.2.2.1 基本思想"></a>4.2.2.1 基本思想</h5><p>• 根据作业的实际需要，动态地为之分配内存空间</p><p>• 划分的时间、大小、位置都是动态的</p><h5 id="4-2-2-2-优缺点"><a href="#4-2-2-2-优缺点" class="headerlink" title="4.2.2.2 优缺点"></a>4.2.2.2 优缺点</h5><p>§ <strong>优点</strong></p><p>• 没有内碎片</p><p>• 克服固定分区内存资源的浪费问题，有利于多道程序设计，提高内存资源利用率</p><h5 id="4-2-2-3-动态分配数据结构"><a href="#4-2-2-3-动态分配数据结构" class="headerlink" title="4.2.2.3 动态分配数据结构"></a>4.2.2.3 动态分配数据结构</h5><ul><li><p>位图表示法（分区表）：给每个分配单元赋予一个字位，用来记录该分配单元是否闲置。例如，字位取值为0表示单元闲置，取值为1则表示已被占用</p><p>• 空间成本固定：不依赖于内存中的程序数量</p><p>• 时间成本低：操作简单，直接修改其位图值即可</p><p>• 没有容错能力：如果一个分配单元为1，不能肯定应该为1还是因错误变成1</p></li><li><p>链表表示法（分区链表）：将分配单元按照是否闲置链接起来，这种方法称为链表表示法。如上图所示的的位图所表示的内存分配状态</p><p>• 空间成本：取决于程序的数量</p><p>• 时间成本：链表扫描通常速度较慢，还要进行链表项的插入、删除和修改</p><p>• 有一定容错能力：因为链表有被占空间和闲置空间的表项，可以相互验证</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603214450192.png" alt="image-20240603214450192"></p></li></ul><h5 id="4-2-2-4-主要算法"><a href="#4-2-2-4-主要算法" class="headerlink" title="4.2.2.4 主要算法"></a>4.2.2.4 主要算法</h5><h6 id="BestFit"><a href="#BestFit" class="headerlink" title="BestFit"></a>BestFit</h6><p>往往使剩下的空闲区非常小，从而在存储器中留下许多难以利用的小空闲区</p><h6 id="WorstFit"><a href="#WorstFit" class="headerlink" title="WorstFit"></a>WorstFit</h6><p>大作业存储空间的申请往往会得不到满足</p><h6 id="FirstFit"><a href="#FirstFit" class="headerlink" title="FirstFit"></a>FirstFit</h6><ul><li><strong>优点：</strong></li></ul><p>• 分配和释放的时间性能较好</p><p>• 较大的空闲分区保留在内存的高端</p><ul><li><strong>缺点：</strong></li></ul><p>• 随着低端内存被不断分配，会产生很多小分区，开销会增大</p><h6 id="NextFit"><a href="#NextFit" class="headerlink" title="NextFit"></a>NextFit</h6><p>使存储空间的利用更加均衡，不致使小的空闲区集中在存储区的一端，但这会导致缺乏大的空闲分区</p><h4 id="4-2-3-覆盖与交换"><a href="#4-2-3-覆盖与交换" class="headerlink" title="4.2.3 覆盖与交换"></a>4.2.3 覆盖与交换</h4><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法，可以解决在小的内存空间运行大作业的问题。</p><h5 id="4-2-3-1-覆盖"><a href="#4-2-3-1-覆盖" class="headerlink" title="4.2.3.1 覆盖"></a>4.2.3.1 覆盖</h5><p>定义：把<strong>一个程序</strong>划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享主存的同一个区域。</p><p>原理：程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段。</p><p>要求：作业各模块之间有明确的调用结构，程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖。</p><p>缺点：对用户不透明，增加了用户负担。</p><h5 id="4-2-3-2-交换"><a href="#4-2-3-2-交换" class="headerlink" title="4.2.3.2 交换"></a>4.2.3.2 交换</h5><p>定义：把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移到辅存中去，以便腾出必要的存储空间；接着把指定程序或数据从辅存读到相应的主存中，并将控制转给它，让其在系统中运行。</p><p>优点：增加并发运行的程序数目，并且给用户提供适当的响应时间；编写程序时不影响程序结构。</p><p>缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑执行过程中地址访问的统计特性。</p><p>选择原则：等待I/O的进程。</p><p>交换时机的确定：只要不用就换出；只在内存空间不够或有不够的危险时换出。</p><h5 id="4-2-3-3-区别"><a href="#4-2-3-3-区别" class="headerlink" title="4.2.3.3 区别"></a>4.2.3.3 区别</h5><p>§ 覆盖可减少一个程序运行所需的空间。交换可让整个程序暂存于外存中，让出内存空间</p><p>§ 覆盖是由程序员实现的，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。交换技术不要求程序员给出程序段之间的覆盖结构</p><p>§ 覆盖技术主要对==同一个作业或程序==进行。交换主要在作业或程序间之间进行</p><h3 id="4-3-页式存储管理"><a href="#4-3-页式存储管理" class="headerlink" title="4.3 页式存储管理"></a>4.3 页式存储管理</h3><p>主要目的：==提高内存空间利用率==。页面与源程序==不存在逻辑关系==。</p><h4 id="4-3-1-页面、页框"><a href="#4-3-1-页面、页框" class="headerlink" title="4.3.1 页面、页框"></a>4.3.1 页面、页框</h4><ul><li>页/页面：在分页存储管理系统中，把每个作业的地址空间分成一些==大小相等的片==</li><li>存储块/页框：把主存的存储空间分成与==页面相同大小的片==</li></ul><h4 id="4-3-2-地址转换"><a href="#4-3-2-地址转换" class="headerlink" title="4.3.2 地址转换"></a>4.3.2 地址转换</h4><p>CPU地址划分为：虚拟页号+页内偏移。</p><p>如果逻辑地址空间为$2^m$，且页大小为$2^n$单元，那么逻辑地址的高m-n位表示页号（页表的索引），而低n位表示页偏移。</p><h5 id="4-3-2-1-MMU"><a href="#4-3-2-1-MMU" class="headerlink" title="4.3.2.1 MMU"></a>4.3.2.1 MMU</h5><h5 id="4-3-2-2-页表"><a href="#4-3-2-2-页表" class="headerlink" title="4.3.2.2 页表"></a>4.3.2.2 页表</h5><p>包含多个页表项，存储虚拟页到物理页的映射</p><h6 id="4-3-2-2-1-多级页表"><a href="#4-3-2-2-1-多级页表" class="headerlink" title="4.3.2.2.1 多级页表"></a>4.3.2.2.1 多级页表</h6><h6 id="4-3-2-2-2-杂凑页表"><a href="#4-3-2-2-2-杂凑页表" class="headerlink" title="4.3.2.2.2 杂凑页表"></a>4.3.2.2.2 杂凑页表</h6><h6 id="4-3-2-2-3-反置页表"><a href="#4-3-2-2-3-反置页表" class="headerlink" title="4.3.2.2.3 反置页表"></a>4.3.2.2.3 反置页表</h6><p>不是依据进程的逻辑页号来组织，而是依据该进程在内存中的物理页面号来组织（即：==按物理页面号排列==），其表项的内容是逻辑页号 P 及隶属进程标志符 pid</p><p>大小只与物理内存的大小相关，==优点：页表占用的内存空间小==</p><h5 id="4-3-2-3-快表TLB"><a href="#4-3-2-3-快表TLB" class="headerlink" title="4.3.2.3 快表TLB"></a>4.3.2.3 快表TLB</h5><p>一种特殊的高速缓冲存储器（Cache） ，内容是页表中的一部分或全部内容。</p><p>CPU 产生逻辑地址的页号，首先在快表中寻找，若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将之复制到快表。若快表中内容满，则按某种算法淘汰某些页</p><h5 id="4-3-2-4-页面的大小"><a href="#4-3-2-4-页面的大小" class="headerlink" title="4.3.2.4 页面的大小"></a>4.3.2.4 页面的大小</h5><p>最常用的页面大小为$4KB$。</p><p><strong>若页面较小</strong></p><p>• 减少页内碎片和总的内存碎片，有利于提高内存利用率。</p><p>• 每个进程页面数增多，使页表长度增加，占用内存较大。</p><p>• 页面换进换出速度将降低。</p><p><strong>若页面较大</strong></p><p>• 每个进程页面数减少，页表长度减少，占用内存较小。</p><p>• 页面换进换出速度将提高。</p><p>• 增加页内碎片，不利于提高内存利用率</p><h4 id="4-3-3-自映射"><a href="#4-3-3-自映射" class="headerlink" title="4.3.3 自映射"></a>4.3.3 自映射</h4><p>页目录表基址 $PD_{base}$:</p><p>$PD<em>{base}=PT</em>{base}|(PT_{base})&gt;&gt;10$</p><p>自映射目录表项$PDE_{self-mapping}$:</p><p>$PDE<em>{self-mapping}=PT</em>{base}|(PT<em>{base})&gt;&gt;10|(PT</em>{base})&gt;&gt;20$</p><h3 id="4-4-段式存储管理"><a href="#4-4-段式存储管理" class="headerlink" title="4.4 段式存储管理"></a>4.4 段式存储管理</h3><h4 id="4-4-1-基本思想"><a href="#4-4-1-基本思想" class="headerlink" title="4.4.1 基本思想"></a>4.4.1 基本思想</h4><p>主要是==满足用户（程序员）编程和使用要求==。程序更多采用分段结构，源程序经编译或汇编后，仍按照==自身逻辑关系分为若干段==。段之间的地址不一定连续，而段内地址一定连续。</p><ul><li>方便编程</li><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接</li></ul><h4 id="4-4-2-地址变换"><a href="#4-4-2-地址变换" class="headerlink" title="4.4.2 地址变换"></a>4.4.2 地址变换</h4><p>==二维地址结构（段号：段内地址）==。</p><p>这种地址结构需要编译程序的支持，但对程序员而言是透明的。</p><h4 id="4-4-3-分页与分段的比较（辨析异同）"><a href="#4-4-3-分页与分段的比较（辨析异同）" class="headerlink" title="4.4.3 分页与分段的比较（辨析异同）"></a>4.4.3 分页与分段的比较（辨析异同）</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240603223443185.png" alt="image-20240603223443185"></p><ul><li><p>优点</p><p>分段系统易于实现段的共享，对段的保护也十分简单</p></li><li><p>缺点</p><ul><li>处理机要为地址变换花费时间；要为表格提供附加的存储空间</li><li>为满足分段的动态增长和减少外零头，要采用拼接手段。</li><li>在辅存中管理不定长度的分段困难较多</li><li>分段的最大尺寸受到主存可用空间的限制</li></ul></li></ul><h4 id="4-4-4-段页式内存管理"><a href="#4-4-4-段页式内存管理" class="headerlink" title="4.4.4 段页式内存管理"></a>4.4.4 段页式内存管理</h4><h5 id="4-4-4-1-基本思想"><a href="#4-4-4-1-基本思想" class="headerlink" title="4.4.4.1 基本思想"></a>4.4.4.1 基本思想</h5><p>用分段方法来分配和管理虚拟存储器，而用分页方法来分配和管理实存储器。</p><h5 id="4-4-4-2-实现原理"><a href="#4-4-4-2-实现原理" class="headerlink" title="4.4.4.2 实现原理"></a>4.4.4.2 实现原理</h5><ul><li><p>段页式存储管理是分段和分页原理的结合，即先将用户程序分成若干个段（段式） ，并为每一个段赋一个段名，再把每个段分成若干个页（页式） 。</p></li><li><p>其地址结构由段号、段内页号、及页内位移三部分所组成。</p></li><li>设段表和页表，均存放于内存中，读一字节的指令或数据须访问内存三次。每个进程一张段表，每个段一张页表。</li></ul><h3 id="4-5-虚拟存储：原理与算法"><a href="#4-5-虚拟存储：原理与算法" class="headerlink" title="4.5 虚拟存储：原理与算法"></a>4.5 虚拟存储：原理与算法</h3><p>自动实现部分装入和部分对装。</p><h4 id="4-5-1-内存访问的局部性原理"><a href="#4-5-1-内存访问的局部性原理" class="headerlink" title="4.5.1 内存访问的局部性原理"></a>4.5.1 内存访问的局部性原理</h4><p>指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。还可以表现为：</p><p>• ==时间局部性==，即一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；</p><p>• ==空间局部性==，即当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内。</p><h4 id="4-5-2-页面置换策略"><a href="#4-5-2-页面置换策略" class="headerlink" title="4.5.2 页面置换策略"></a>4.5.2 页面置换策略</h4><h5 id="最优算法：OPT"><a href="#最优算法：OPT" class="headerlink" title="最优算法：OPT"></a>最优算法：OPT</h5><p>页错误率最低，无法被实现。</p><p>淘汰页应是==以后不再访问==的页或==距现在最长时间后再访问的页==。</p><h5 id="先进先出：FIFO"><a href="#先进先出：FIFO" class="headerlink" title="先进先出：FIFO"></a>先进先出：FIFO</h5><p>淘汰页：==最先调入内存==的页。</p><p>==性能较差==，有Belady现象。</p><blockquote><h6 id="Belady"><a href="#Belady" class="headerlink" title="Belady"></a>Belady</h6><p>在使用FIFO算法作为缺页置换算法时，分配的缺页增多，但缺页率反而提高。</p><p>在使用FIFO算法作为缓存算法时，同样也会遇到类似情况：增加缓存容量，但缓存命中率也会下降。</p></blockquote><h5 id="第二次机会算法SCR"><a href="#第二次机会算法SCR" class="headerlink" title="第二次机会算法SCR"></a>第二次机会算法SCR</h5><p>==改进的FIFO==。其思想：“如果被淘汰的数据之前被访问过，则给其第二次机会”。</p><h5 id="时钟算法：Clock"><a href="#时钟算法：Clock" class="headerlink" title="时钟算法：Clock"></a>时钟算法：Clock</h5><p>==改进的FIFO==，也称最近未使用算法（NRU），通过一个环形队列，避免将数据在FIFO队列中移动。</p><h5 id="FIFO类算法对比"><a href="#FIFO类算法对比" class="headerlink" title="FIFO类算法对比"></a>FIFO类算法对比</h5><div class="table-container"><table><thead><tr><th>对比点</th><th>对比</th></tr></thead><tbody><tr><td>命中率</td><td><strong>Clock = SCR &gt; FIFO</strong></td></tr><tr><td>复杂度</td><td><strong>SCR &gt; Clock &gt; FIFO</strong></td></tr><tr><td>代价</td><td><strong>SCR &gt; Clock &gt; FIFO</strong></td></tr></tbody></table></div><h5 id="最近最少使用：LRU"><a href="#最近最少使用：LRU" class="headerlink" title="最近最少使用：LRU"></a>最近最少使用：LRU</h5><p>思想：“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p>局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p><h5 id="老化算法：AGING"><a href="#老化算法：AGING" class="headerlink" title="老化算法：AGING"></a>老化算法：AGING</h5><p>==LRU的简化，但性能接近LRU==。为每个页码设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入。</p><h5 id="最不频繁使用：LFU"><a href="#最不频繁使用：LFU" class="headerlink" title="最不频繁使用：LFU"></a>最不频繁使用：LFU</h5><h5 id="工作集策略"><a href="#工作集策略" class="headerlink" title="工作集策略"></a>工作集策略</h5><p>进程的==工作集==：当前正在使用的页面的集合；</p><p>进程的==驻留集==：虚拟存储系统中，每个进程驻留在内存的页面集合，或进程分到的物理页框集合。</p><p>引入工作集的目的：依据进程在过去的一段时间内访问的页面来调整驻留集大小。</p><p>工作集策略：NT根据内存负荷和进程缺页情况自动调整工作集。进程创建时，指定一个最小工作集，当内核负荷不太大时，允许进程拥有尽可能多的页面；系统通过自动调整保证内存中有一定的空闲页面存在。</p><h4 id="4-5-3-缺页中断率"><a href="#4-5-3-缺页中断率" class="headerlink" title="4.5.3 缺页中断率"></a>4.5.3 缺页中断率</h4><h3 id="4-6-其他内容"><a href="#4-6-其他内容" class="headerlink" title="4.6 其他内容"></a>4.6 其他内容</h3><h4 id="4-6-1-内存抖动"><a href="#4-6-1-内存抖动" class="headerlink" title="4.6.1 内存抖动"></a>4.6.1 内存抖动</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>随着驻留内存的进程数目增加，或者说进程并发水平的上升，处理器利用率先是上升，然后下降。这里下降的原因通常称为虚拟存储器发生“抖动”，即每个进程的驻留集不断减小，当驻留集小于工作集后，缺页率急剧上升频繁调页使得调页开销增大。</p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul><li>局部置换策略（微观层面）：正在抖动的进程不能从另外的进程夺取内存块。并未消除抖动的发生。</li><li>引入工作集算法（微观）</li><li>预留部分页面（微观或宏观）</li><li>挂起若干进程：消除抖动现象（宏观）</li></ul><h4 id="4-6-2-写时复制技术"><a href="#4-6-2-写时复制技术" class="headerlink" title="4.6.2 写时复制技术"></a>4.6.2 写时复制技术</h4><h4 id="4-6-3-内存映射文件"><a href="#4-6-3-内存映射文件" class="headerlink" title="4.6.3 内存映射文件"></a>4.6.3 内存映射文件</h4><h4 id="4-6-4-存储保护"><a href="#4-6-4-存储保护" class="headerlink" title="4.6.4 存储保护"></a>4.6.4 存储保护</h4><h2 id="5-进程机制与并发程序设计"><a href="#5-进程机制与并发程序设计" class="headerlink" title="5 进程机制与并发程序设计"></a>5 进程机制与并发程序设计</h2><h3 id="5-1-进程与线程的基本概念"><a href="#5-1-进程与线程的基本概念" class="headerlink" title="5.1 进程与线程的基本概念"></a>5.1 进程与线程的基本概念</h3><h4 id="5-1-1-并发与并行"><a href="#5-1-1-并发与并行" class="headerlink" title="5.1.1 并发与并行"></a>5.1.1 并发与并行</h4><p>并发：设有两个活动a1和a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都在执行中，则称a1和a2是并发执行的。</p><p>并行：两个程序在某一指定的时间t，同时运行在<strong>不同</strong>的处理机上。</p><p>并行性的确定-Bernstein条件：两个进程S1和S2可并发，当且仅当下列条件同时成立：</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145415008.png" alt="image-20240604145415008"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145406288.png" alt="image-20240604145406288"></p><h4 id="5-1-2-进程与程序"><a href="#5-1-2-进程与程序" class="headerlink" title="5.1.2 进程与程序"></a>5.1.2 进程与程序</h4><p>程序：静态的。静态的实体，是存放在磁盘上的可执行文件</p><p>进程：动态的。执行中的程序。进程包括程序和程序处理对象（数据集），是一个程序对某个数据集的执行过程，是分配资源的基本单位。通常把进程分为系统进程和用户进程两大类。进程的三个特征：并发、共享、不确定性。</p><p>作业：用户需要计算机完成的某项任务，是要求计算机所做工作的集合</p><h4 id="5-1-3-进程的三个基本状态、转换条件"><a href="#5-1-3-进程的三个基本状态、转换条件" class="headerlink" title="5.1.3 进程的三个基本状态、转换条件"></a>5.1.3 进程的三个基本状态、转换条件</h4><ul><li>就绪状态：进程已获得除处理机外的所需资源，等待分配处理机资源；只要分配CPU就可执行；</li><li>执行状态：占用处理机资源；</li><li>阻塞状态：正在执行的进程由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。</li></ul><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145724107.png" alt="image-20240604145724107"></p><h4 id="5-1-4-进程的控制原语"><a href="#5-1-4-进程的控制原语" class="headerlink" title="5.1.4 进程的控制原语"></a>5.1.4 进程的控制原语</h4><p>原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能。</p><ul><li><p>特点</p><ol><li>指令序列执行是连续的，不可分割</li><li>是操作系统核心组成部分</li><li>必须在管态下执行，且常驻内存</li></ol></li><li><p>和系统调用的区别：</p><p><a href="https://blog.csdn.net/weixin_46248230/article/details/133207862" target="_blank" rel="noopener">原语是操作系统核心态下的原子性操作，强调原子性；系统调用是用户程序和操作系统的接口，为用户程序提供系统服务。原语常驻内存，必须在管态执行，而系统调用在用户态执行，对应的服务程序在内核态执行</a></p></li><li><p>创建原语：<code>fork</code>, <code>exec</code></p><p>==Fork()函数==：</p><p>fork调用仅仅被调用一次，却能返回两次，它可能有三种不同的返回值：</p><ol><li>在父进程中，fork返回新创建子进程的进程ID；</li><li>在子进程中，fork返回0；</li><li>如果出现错误，fork返回一个负值；</li></ol></li><li><p>撤销原语：<code>kill</code></p></li></ul><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604145952434.png" alt="image-20240604145952434"></p><h4 id="5-1-5-进程的组成：程序、数据、PCB"><a href="#5-1-5-进程的组成：程序、数据、PCB" class="headerlink" title="5.1.5 进程的组成：程序、数据、PCB"></a>5.1.5 进程的组成：程序、数据、PCB</h4><h4 id="5-1-6-进程与线程的区别"><a href="#5-1-6-进程与线程的区别" class="headerlink" title="5.1.6 进程与线程的区别"></a>5.1.6 进程与线程的区别</h4><p>进程是资源拥有者，线程是可执行单元。</p><p>进程拥有虚空间、进程映像、处理机保护、文件、I/O空间。</p><p>线程额外的资源：运行状态、保存上下文（程序计数器）、执行栈、资源共享机制。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604164345788.png" alt="image-20240604164345788"></p><h4 id="5-1-7-线程的实现方式"><a href="#5-1-7-线程的实现方式" class="headerlink" title="5.1.7 线程的实现方式"></a>5.1.7 线程的实现方式</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604154833392.png" alt="image-20240604154833392"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604154854666.png" alt="image-20240604154854666"></p><h5 id="5-1-7-1-用户级线程"><a href="#5-1-7-1-用户级线程" class="headerlink" title="5.1.7.1 用户级线程"></a>5.1.7.1 用户级线程</h5><p>线程在用户空间，不需要或仅需要极少的kernel支持。</p><p>上下文切换比较快。</p><p>用户级的线程库的主要功能：</p><ul><li>创建和销毁线程</li><li>线程之间传递消息和数据</li><li>调度线程执行</li><li>保存和恢复线程上下文</li></ul><p><strong>优点</strong></p><ul><li>线程切换与内核无关</li><li>线程的调度由应用决定，容易进行优化</li><li>可运行在任何操作系统上，只需要线程库的支持</li></ul><p><strong>缺点</strong></p><ul><li>一个线程阻塞，所有相关的线程也会被内核阻塞。</li><li>阻塞发生在进程级别。内核只能将处理器分配给进程。即使有多个处理器，也无法实现一个进程中的多个线程的并发执行。</li></ul><h5 id="5-1-7-2-内核级线程"><a href="#5-1-7-2-内核级线程" class="headerlink" title="5.1.7.2 内核级线程"></a>5.1.7.2 内核级线程</h5><p>思想：kernel有好几个分身，一个分身可以处理一件事。</p><p><strong>优点</strong></p><ul><li>内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li><li>阻塞发生在线程级别</li><li>内核中的一些处理可以通过多线程实现</li></ul><p><strong>缺点</strong></p><ul><li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li><li>降低效率</li></ul><h5 id="5-1-7-3-混合实现方式"><a href="#5-1-7-3-混合实现方式" class="headerlink" title="5.1.7.3 混合实现方式"></a>5.1.7.3 混合实现方式</h5><p>线程在用户空间创建和管理。需要实现从用户空间的线程到内核空间线程（轻量级进程）的映射。</p><h3 id="5-2-进程调度算法"><a href="#5-2-进程调度算法" class="headerlink" title="5.2 进程调度算法"></a>5.2 进程调度算法</h3><h4 id="5-2-1-调度的三个类型：高级、中级、低级"><a href="#5-2-1-调度的三个类型：高级、中级、低级" class="headerlink" title="5.2.1 调度的三个类型：高级、中级、低级"></a>5.2.1 调度的三个类型：高级、中级、低级</h4><h5 id="5-2-1-1-高级调度-宏观调度-作业调度"><a href="#5-2-1-1-高级调度-宏观调度-作业调度" class="headerlink" title="5.2.1.1 高级调度/宏观调度/作业调度"></a>5.2.1.1 高级调度/宏观调度/作业调度</h5><p>==用户角度==，一次提交若干个作业，对每个作业进行调度。</p><h5 id="5-2-1-2-中级调度-内外存交换"><a href="#5-2-1-2-中级调度-内外存交换" class="headerlink" title="5.2.1.2 中级调度/内外存交换"></a>5.2.1.2 中级调度/内外存交换</h5><p>==存储器资源管理==的角度，将进程的部分或全部换出到外存上，将当前所需部分换入到内存。</p><h5 id="5-2-2-1-3-低级调度-微观调度-进程或线程调度"><a href="#5-2-2-1-3-低级调度-微观调度-进程或线程调度" class="headerlink" title="5.2.2=1.3 低级调度/微观调度/进程或线程调度"></a>5.2.2=1.3 低级调度/微观调度/进程或线程调度</h5><p>==CPU资源管理==的角度，执行的单位。</p><h4 id="5-2-2-进程调度算法"><a href="#5-2-2-进程调度算法" class="headerlink" title="5.2.2 进程调度算法"></a>5.2.2 进程调度算法</h4><h5 id="5-2-2-1-总体上：非抢占、抢占"><a href="#5-2-2-1-总体上：非抢占、抢占" class="headerlink" title="5.2.2.1 总体上：非抢占、抢占"></a>5.2.2.1 总体上：非抢占、抢占</h5><p>抢占即，就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，立即进行进程调度。</p><h5 id="5-2-2-2-评价指标："><a href="#5-2-2-2-评价指标：" class="headerlink" title="5.2.2.2 评价指标："></a>5.2.2.2 <strong>评价指标：</strong></h5><p>–<strong>周转时间、平均周转时间、带权平均周转时间</strong></p><ul><li>$周转时间=完成时刻-提交时刻$</li><li>$带权周转时间=周转时间/服务时间(执行时间)$</li><li>$平均周转时间=作业周转时间之和/作业数$</li><li>$平均带权周转时间=作业带权周转时间之和/作业数$</li></ul><p>–<strong>吞吐量</strong></p><p>$吞吐量=作业数/总执行时间$，即单位时间CPU完成的作业数量</p><p>–<strong>响应时间</strong></p><h5 id="5-2-2-3-常见调度算法"><a href="#5-2-2-3-常见调度算法" class="headerlink" title="5.2.2.3 常见调度算法"></a>5.2.2.3 常见调度算法</h5><h6 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h6><p>最简单的调度算法，按先后顺序调度。非抢占式。</p><p>比较有利于长作业、CPU繁忙的作业。不适合短作业、I/O繁忙的作业。</p><h6 id="短作业优先SJF"><a href="#短作业优先SJF" class="headerlink" title="短作业优先SJF"></a>短作业优先SJF</h6><p>对FCFS的改进，目标：减少平均周转时间</p><p>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢占正在执行的作业。</p><p>优点：比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间。提高系统的吞吐量。</p><p>缺点：对长作业非常不利。未能依据作业的紧迫程度来划分执行的优先级；难以准确估计执行时间从而影响调度性能。</p><h6 id="最短剩余时间优先SRTN"><a href="#最短剩余时间优先SRTN" class="headerlink" title="最短剩余时间优先SRTN"></a>最短剩余时间优先SRTN</h6><p>对SJF的改进，改进为==抢占式==。即一个新就绪的进程比当前运行进程具有更短的完成时间，系统抢占当前进程。</p><p>缺点：长任务==饥饿==。</p><h6 id="最高响应比优先HRRN"><a href="#最高响应比优先HRRN" class="headerlink" title="最高响应比优先HRRN"></a>最高响应比优先HRRN</h6><p>FCFS和SJF的折中。非抢占式。既考虑作业的运行时间，也考虑作业的运行时间。既照顾短作业又不使长作业的等待时间过长。</p><p>计算后备作业队列中每个作业的响应比RP，然后选择其值最大的作业投入运行。RP值定义为：</p><p>$RP=(作业已等待时间+作业的服务时间)/作业的服务时间=1+作业已等待时间/作业的服务时间$</p><p>饥饿现象不会发生。但每次计算各道作业的响应比会有一定的时间开销。</p><h6 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h6><p>微观调度，目标：提高资源利用率。时间片过长会退化为FCFS算法。</p><p>算法流程：</p><p>§ <strong>将系统中所有的就绪进程按照FCFS原则，排成一个队列。</strong></p><p>§ <strong>每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。</strong></p><p>§ <strong>在一个时间片结束时，发生时钟中断。</strong></p><p>§ <strong>调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</strong></p><p>§ <strong>进程可以未使用完一个时间片，就出让CPU（如阻塞）。</strong></p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>可分成抢先式和非抢先式。</p><ul><li>静态优先级：创建进程时就确定，直到进程终止前都不改变。</li><li>动态优先级：在创建进程时赋予的优先级，在进程运行过程中可以自动改变。</li><li>优先级倒置（反转）：高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。解决方法：<ol><li>优先级置顶。当进程进入临界区后，其占用的处理机就不允许被抢占。</li><li>优先级继承。当高优先级进程要进入临界区使用临界资源X时，如果已经有一个低优先级进程正在使用该资源，则可以优先级继承。</li></ol></li></ul><h6 id="多级反馈队列算法MFQ"><a href="#多级反馈队列算法MFQ" class="headerlink" title="多级反馈队列算法MFQ"></a>多级反馈队列算法MFQ</h6><p>时间片轮转算法和优先级算法的综合和发展。</p><h5 id="5-2-2-4-实时调度算法"><a href="#5-2-2-4-实时调度算法" class="headerlink" title="5.2.2.4 实时调度算法"></a>5.2.2.4 实时调度算法</h5><h6 id="单调速率调度RMS"><a href="#单调速率调度RMS" class="headerlink" title="单调速率调度RMS"></a>单调速率调度RMS</h6><p>单处理器下的==最优静态调度算法==。可通过对系统资源利用率的计算来进行任务可调度性分析。实时调度的基础性理论。</p><p>任务的周期越小，其优先级越高。优先级最高的任务最先被调度。如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度。</p><h6 id="最早截止时间优先算法EDF"><a href="#最早截止时间优先算法EDF" class="headerlink" title="最早截止时间优先算法EDF"></a>最早截止时间优先算法EDF</h6><p>任务的绝对截止时间越早，其优先级越高。</p><p>任务集可调度的充分必要条件：</p><p>$\sum_{i=1}^{n}\frac{C_i}{T_i}\leqslant1$</p><h6 id="最低松弛度优先算法LLF"><a href="#最低松弛度优先算法LLF" class="headerlink" title="最低松弛度优先算法LLF"></a>最低松弛度优先算法LLF</h6><p>根据任务紧急的程度，来确定任务的优先级。任务的紧急度越高，其优先级越高，并使之优先执行。</p><p>==$松弛度=任务截止时间-本身剩余运行时间-当前时间$==</p><p>调度时机：有进程执行完或有进程的松弛度（Laxity）为0时</p><p>任务集可调度的充分必要条件：</p><p>$\sum_{i=1}^{n}\frac{C_i}{T_i}\leqslant1$</p><h4 id="5-2-3-多处理机调度"><a href="#5-2-3-多处理机调度" class="headerlink" title="5.2.3 多处理机调度"></a>5.2.3 多处理机调度</h4><h5 id="5-2-3-1-系统"><a href="#5-2-3-1-系统" class="headerlink" title="5.2.3.1 系统"></a>5.2.3.1 系统</h5><ul><li>非对称式多处理系统（AMP）</li><li>对称式多处理系统（SMP）<ol><li>自调度：所有CPU采用一个公共就绪队列。各个处理机自行在就绪队列中取任务。</li></ol></li></ul><h5 id="5-2-3-2-调度"><a href="#5-2-3-2-调度" class="headerlink" title="5.2.3.2 调度"></a>5.2.3.2 调度</h5><ul><li>自调度</li><li>成组调度</li><li>专用处理机调度</li></ul><h3 id="5-3-进程通信"><a href="#5-3-进程通信" class="headerlink" title="5.3 进程通信"></a>5.3 进程通信</h3><h4 id="5-3-1-类型"><a href="#5-3-1-类型" class="headerlink" title="5.3.1 类型"></a>5.3.1 类型</h4><h5 id="5-3-1-1-低级通信"><a href="#5-3-1-1-低级通信" class="headerlink" title="5.3.1.1 低级通信"></a>5.3.1.1 低级通信</h5><p>只能传递状态和整数值，包括进程互斥和同步所采用的信号量和管程机制。</p><p>缺点：传送信息量小、编程复杂。</p><h5 id="5-3-1-2-高级通信"><a href="#5-3-1-2-高级通信" class="headerlink" title="5.3.1.2 高级通信"></a>5.3.1.2 高级通信</h5><ul><li>==管道==<ol><li>无名管道（Pipe）：<ul><li>==半双工==，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><li>==只能用于父子进程或兄弟进程==之间（具有亲缘关系的进程）；</li><li>单独构成一种==独立的文件系统==，==只存在内存中==；</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul></li><li>有名管道（Named Pipe或FIFO）<ul><li>可以用于能够访问FIFO路径的进程以及FIFO的创建进程之间。因此通过FIFO不相关的进程也能交换数据；</li><li>严格遵循先进先出，数据的读出和写入同无名管道。</li></ul></li></ol></li><li>==共享内存==<ol><li>==最有用==的进程间通信方式，也是==最快==的IPC形式（原因：避免了其他形式的IPC必须执行的开销巨大的缓冲复制）</li><li>两个不同进程A、B共享内存的意义是，==同一块物理内存被映射到进程A、B各自的进程地址空间==。</li><li>当多个进程共享同一块内存区域，由于共享内存可以同时读但不能同时写</li></ol></li><li>==消息系统==<ol><li>消息传递：两个通信原语（<code>send</code>, <code>receive</code>）</li><li>调用方式：阻塞调用、非阻塞调用</li></ol></li></ul><h4 id="5-3-2-临界资源、临界区"><a href="#5-3-2-临界资源、临界区" class="headerlink" title="5.3.2 临界资源、临界区"></a>5.3.2 临界资源、临界区</h4><p>临界资源：一次仅允许一个进程访问的资源；</p><p>临界区：每个进程中访问临界资源的那段代码；</p><h4 id="5-3-3-同步、互斥"><a href="#5-3-3-同步、互斥" class="headerlink" title="5.3.3 同步、互斥"></a>5.3.3 同步、互斥</h4><p>互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。访问是==无需访问==。==（间接制约关系）==</p><p>同步：在互斥的基础上，通过其他机制实现访问者对资源的==有序访问==。==（直接制约关系）==</p><h5 id="5-3-3-1-原则"><a href="#5-3-3-1-原则" class="headerlink" title="5.3.3.1 原则"></a>5.3.3.1 原则</h5><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><h5 id="5-3-3-2-经典问题"><a href="#5-3-3-2-经典问题" class="headerlink" title="5.3.3.2 经典问题"></a>5.3.3.2 经典问题</h5><blockquote><p>全面练习：孙海龙-13-4.2-进程管理-同步与互斥.ppt</p></blockquote><h6 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h6><p>若干进程通过有限的共享缓冲区交换数据。</p><h6 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h6><h6 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h6><ul><li>破除==资源互斥==：至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放他所使用的两支筷子。</li><li>破除==循环等待==：对筷子进行编号，每个哲学家按编号从低到高拿起筷子；或对哲学家编号，奇数先左后右，偶数相反。</li><li>破除==请求且保持==：同时拿起两根筷子，否则不拿起。</li></ul><h6 id="理发师"><a href="#理发师" class="headerlink" title="理发师"></a>理发师</h6><h4 id="5-3-4-信号量、PV操作"><a href="#5-3-4-信号量、PV操作" class="headerlink" title="5.3.4 信号量、PV操作"></a>5.3.4 信号量、PV操作</h4><p>信号量是一类特殊的变量，程序对其访问都是原子操作，且只允许对它进行P和V操作。</p><p>当信号量为正时，表示资源的个数；</p><p>当信号量为负时，表示等待进程的个数。</p><h5 id="5-3-4-1-优缺点"><a href="#5-3-4-1-优缺点" class="headerlink" title="5.3.4.1 优缺点"></a>5.3.4.1 优缺点</h5><ul><li>优点：简单，而且==表达能力强==（用PV操作可解决==任何==同步互斥问题）。</li><li>缺点：不够安全；PV操作使用不当会出现==死锁==；遇到复杂同步互斥问题时实现复杂。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span> </span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span> </span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span></span><br><span class="line">        <span class="comment">/* place process P on ready list</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="5-3-4-2-实现汇合（Rendezvous）"><a href="#5-3-4-2-实现汇合（Rendezvous）" class="headerlink" title="5.3.4.2 实现汇合（Rendezvous）"></a>5.3.4.2 实现汇合（Rendezvous）</h5><p>目的：a1永远在b2之前，而b1永远在a2之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore aArrived = <span class="number">0</span>, bArrived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread A */</span></span><br><span class="line">statement a1;</span><br><span class="line">V(aArrived);</span><br><span class="line">P(bArrived);</span><br><span class="line">statement a2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread B */</span></span><br><span class="line">statement b1;</span><br><span class="line">V(bArrived);</span><br><span class="line">P(aArrived);</span><br><span class="line">statement b2;</span><br></pre></td></tr></table></figure><h5 id="5-3-4-3-屏障Barriers"><a href="#5-3-4-3-屏障Barriers" class="headerlink" title="5.3.4.3 屏障Barriers"></a>5.3.4.3 屏障Barriers</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604161746827.png" alt="image-20240604161746827"></p><h5 id="5-3-4-4-信号量集机制"><a href="#5-3-4-4-信号量集机制" class="headerlink" title="5.3.4.4 信号量集机制"></a>5.3.4.4 信号量集机制</h5><p>▪ SP(S, d, d)：表示每次申请d个资源，当资源数量少于d个时，便不予分配。</p><p>▪ SP(S, 1, 1)：表示互斥信号量。</p><p>▪ SP(S, 1, 0)：可作为一个可控开关(当S≥1时，允许多个进程进入临界区；当S=0时禁止任何进程进入临界区)。</p><h4 id="5-3-5-管程的基本概念"><a href="#5-3-5-管程的基本概念" class="headerlink" title="5.3.5 管程的基本概念"></a>5.3.5 管程的基本概念</h4><p>是在==程序设计语言==中引入的一个==成分==，是一种高级同步机制。</p><p>管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。需要解决三个问题：互斥、同步、条件变量。</p><blockquote><h6 id="条件变量和信号量的区别："><a href="#条件变量和信号量的区别：" class="headerlink" title="条件变量和信号量的区别："></a>条件变量和信号量的区别：</h6><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604162313118.png" alt="image-20240604162313118"></p></blockquote><h3 id="5-4-死锁问题"><a href="#5-4-死锁问题" class="headerlink" title="5.4 死锁问题"></a>5.4 死锁问题</h3><h4 id="5-4-1-基本概念：死锁、活锁、饥饿"><a href="#5-4-1-基本概念：死锁、活锁、饥饿" class="headerlink" title="5.4.1 基本概念：死锁、活锁、饥饿"></a>5.4.1 基本概念：死锁、活锁、饥饿</h4><p>死锁：一组进程中，每个进程都无限等待组内其他进程所占有的资源，在无外力介入的条件下，将因永远分配不道德资源而无法运行的现象。浪费大量系统资源，甚至导致系统崩溃。发生原因：资源竞争、并发执行的顺序不当。</p><p>活锁：任务或执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败。活锁在不断地改变状态，且有可能自行解开。</p><p>饥饿：某些进程可能由于资源分配策略的不公平导致长时间等待。</p><h4 id="5-4-2-产生死锁的必要条件"><a href="#5-4-2-产生死锁的必要条件" class="headerlink" title="5.4.2 产生死锁的必要条件"></a>5.4.2 产生死锁的必要条件</h4><ul><li>互斥：允许进程同时访问某些资源。</li><li>不可剥夺：允许进程强行从占有者那里夺取资源。</li><li>请求和保持：实现资源预先分配。只有当系统能够满足当前进程的全部资源需求时，才一次性将所申请的资源全部分配给该进程，否则不分配任何进程。</li><li>循环等待：把资源实现分类编号，按号分配。</li></ul><h4 id="5-4-3-进程-资源图-资源分配图"><a href="#5-4-3-进程-资源图-资源分配图" class="headerlink" title="5.4.3 进程-资源图/资源分配图"></a>5.4.3 进程-资源图/资源分配图</h4><h4 id="5-4-4-处理死锁的方法"><a href="#5-4-4-处理死锁的方法" class="headerlink" title="5.4.4 处理死锁的方法"></a>5.4.4 处理死锁的方法</h4><ul><li><p>允许死锁发生：无作为、检测与解除死锁</p></li><li><p>不允许死锁发生：预防死锁、避免死锁</p><ul><li><p>预防死锁（静态）：破坏死锁产生的四个条件</p></li><li><p>避免死锁（动态）：在资源分配之前进行判断。安全性、银行家算法</p><ol><li><p>安全序列：一个序列${P_1,P_2,…,P_n}$安全，指若对于每一个进程$P_i$,它需要的资源可以被系统中当前可用资源加上所有进程$P_j(j&lt;i)$当前占有资源之和所满足。则这是一个安全序列。如果系统不存在这样一个安全序列，则系统是不安全的。系统进入不安全状态也未必产生死锁。产生死锁后，系统一定处于不安全状态。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604165458874.png" alt="image-20240604165458874"></p></li><li><p>银行家算法</p></li></ol></li></ul></li><li><p>检测与解除死锁：</p><ul><li>发现死锁：基于进程-资源图的化简<ol><li>资源分配图中存在环路，不一定存在死锁。</li><li>死锁定理：系统中某个时刻t为死锁状态的充要条件是==t时刻系统的资源分配图是不可完全化简的==。</li><li>在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是可完全化简的；反之的是不可完全化简的。</li></ol></li><li>解除死锁：资源剥夺、撤销进程<ol><li>剥夺资源：挂起一些进程，剥夺其资源以接触死锁，待条件满足时再激活。</li><li>撤销进程：使全部死锁的进程夭折。</li></ol></li><li>无所作为：鸵鸟算法</li></ul></li></ul><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604170307930.png" alt="image-20240604170307930"></p><h2 id="6-输入-输出系统"><a href="#6-输入-输出系统" class="headerlink" title="6 输入/输出系统"></a>6 输入/输出系统</h2><h3 id="6-1-I-O设备及控制"><a href="#6-1-I-O设备及控制" class="headerlink" title="6.1 I/O设备及控制"></a>6.1 I/O设备及控制</h3><p>I/O设备管理具体包括：</p><ul><li>逻辑I/O：完成设备无关的操作，如设备分配、设备回收、数据准备等。</li><li>设备驱动程序：负责对设备控制器进行控制（通过读写其中的寄存器）。</li><li>中断服务程序：设备工作结束后负责向CPU发中断信号，中断服务程序完成相应处理。</li></ul><h4 id="6-1-1-I-O设备"><a href="#6-1-1-I-O设备" class="headerlink" title="6.1.1 I/O设备"></a>6.1.1 I/O设备</h4><p>按数据组织分类：</p><ul><li>块设备：以数据块为单位存储、传输信息。传输速率较高、可寻址（随机读写）。</li><li>字符设备：以字符为单位存储、传输信息。传输速率低、不可寻址。</li></ul><p>按用途分类：</p><ul><li>存储设备：磁盘、磁带；</li><li>传输设备：网卡、Modem；</li><li>人机交互设备：显示器、键盘、鼠标。</li></ul><p>从资源分配角度：</p><ul><li>独占设备：如打印机，磁带机</li><li>共享设备：如硬盘</li><li>虚设备</li></ul><h4 id="6-1-2-I-O控制技术（比较异同）"><a href="#6-1-2-I-O控制技术（比较异同）" class="headerlink" title="6.1.2 I/O控制技术（比较异同）"></a>6.1.2 I/O控制技术（比较异同）</h4><ul><li><p>程序控制/轮询/查询方式IO：由CPU代表进程向I/O模块发出指令，然后进入忙等状态，直到操作完成之后进程才能够继续执行。</p></li><li><p>中断驱动：当I/O操作结束后由设备控制器主动地来通知设备驱动程序，而不是依靠设备驱动程序不断地去轮询看看设备的状态。</p></li><li><p>直接内存访问（DMA）：由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604220717103.png" alt="image-20240604220717103"></p></li><li><p>通道技术（Channel）：与DMA原理几乎一样。通道是一个特殊功能的处理器，它有自己的指令和程序专门负责数据输入输出的传输控制。CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能。这样，通道与CPU分时使用内存，实现了CPU内部运算与I/O设备的并行工作。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604220740772.png" alt="image-20240604220740772"></p></li></ul><h4 id="6-1-3-I-O软件的组成与分层设计"><a href="#6-1-3-I-O软件的组成与分层设计" class="headerlink" title="6.1.3 I/O软件的组成与分层设计"></a>6.1.3 I/O软件的组成与分层设计</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604220829683.png" alt="image-20240604220829683"></p><h4 id="6-1-4-SPOOLing技术-假脱机技术"><a href="#6-1-4-SPOOLing技术-假脱机技术" class="headerlink" title="6.1.4 SPOOLing技术/假脱机技术"></a>6.1.4 SPOOLing技术/假脱机技术</h4><p>可把独享设备转变成具有共享特征的虚拟设备，从而提高设备利用率。</p><p>组成：</p><ul><li>输入井和输出井</li><li>输入缓冲区和输出缓冲区</li><li>输入进程$SP<em>{i}$和输出进程$SP</em>{o}$</li></ul><p>特点：</p><ul><li>高速虚拟I/O操作</li><li>实现对独享设备的共享</li></ul><h3 id="6-2-缓冲区的管理"><a href="#6-2-缓冲区的管理" class="headerlink" title="6.2 缓冲区的管理"></a>6.2 缓冲区的管理</h3><h4 id="6-2-1-缓冲区作用？"><a href="#6-2-1-缓冲区作用？" class="headerlink" title="6.2.1 缓冲区作用？"></a>6.2.1 缓冲区作用？</h4><p>可提高外设利用率。</p><p>原因：</p><ul><li>匹配CPU与外设的不同处理速度。</li><li>减少对CPU的中断次数。</li><li>提高CPU和I/O设备之间的并行性。</li></ul><blockquote><p>设从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为C。</p></blockquote><h4 id="6-2-2-单缓冲区"><a href="#6-2-2-单缓冲区" class="headerlink" title="6.2.2 单缓冲区"></a>6.2.2 单缓冲区</h4><p>由于T和C是可并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之则为M+C。处理时间表示为$Max(C,T)+M$。</p><h4 id="6-2-3-双缓冲区"><a href="#6-2-3-双缓冲区" class="headerlink" title="6.2.3 双缓冲区"></a>6.2.3 双缓冲区</h4><p>在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程(如下图)。接着由 CPU 对数据进行计算。在双缓冲时，系统处理一块数据的时间可以粗略地认为是$Max(C，T)$。如果 C<T，可使块设备连续输入；如果 C>T，则可使 CPU 不必等待设备输入。</p><h4 id="6-2-4-环形缓冲区"><a href="#6-2-4-环形缓冲区" class="headerlink" title="6.2.4 环形缓冲区"></a>6.2.4 环形缓冲区</h4><p>对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用，输入进程不断向空缓冲去输入数据，而计算进程则从中提取数据进行计算。</p><p><strong>循环缓冲区的组成如下</strong></p><p>• 多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为三种类型，用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的工作缓冲区C。</p><p>• 多个指针，作为输入的缓冲区可设置三个指针，用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti、以及用于指示计算进程正在使用的缓冲区C的指针Current</p><h4 id="6-2-5-缓冲池"><a href="#6-2-5-缓冲池" class="headerlink" title="6.2.5 缓冲池"></a>6.2.5 缓冲池</h4><p>上述仅使用于某特定的I/O进程和计算进程，因而它们属于专用缓冲。</p><p>当系统较大时，将会有许多这样的循环缓冲，将消耗大量内存空间且利用率不高。</p><p>共用缓冲池，包含三种类型的缓冲区：</p><ul><li>空缓冲区</li><li>装满输入数据的缓冲区</li><li>装满输出数据的缓冲区</li></ul><h3 id="6-3-I-O管理软件"><a href="#6-3-I-O管理软件" class="headerlink" title="6.3 I/O管理软件"></a>6.3 I/O管理软件</h3><h2 id="7-磁盘存储管理"><a href="#7-磁盘存储管理" class="headerlink" title="7 磁盘存储管理"></a>7 磁盘存储管理</h2><h4 id="7-1-磁盘的工作原理"><a href="#7-1-磁盘的工作原理" class="headerlink" title="7.1 磁盘的工作原理"></a>7.1 磁盘的工作原理</h4><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604225321280.png" alt="image-20240604225321280"></p><h4 id="7-2-磁盘空间的管理"><a href="#7-2-磁盘空间的管理" class="headerlink" title="7.2 磁盘空间的管理"></a>7.2 磁盘空间的管理</h4><p>– 空闲表、空闲链表、位示图、成组链接</p><h4 id="7-3-磁盘访问时间"><a href="#7-3-磁盘访问时间" class="headerlink" title="7.3 磁盘访问时间"></a>7.3 磁盘访问时间</h4><p>– 寻道时间 + 旋转延迟时间 + 传输时间</p><p>$T_a=T_s＋1/(2r)＋ b/(rN)$</p><p>$r:转速(r/s)$, $b:每次所读/写的字节数$, $N:磁道上的字节数$</p><h4 id="7-4-磁盘调度算法"><a href="#7-4-磁盘调度算法" class="headerlink" title="7.4 磁盘调度算法"></a>7.4 磁盘调度算法</h4><h5 id="先来先服务FCFS-1"><a href="#先来先服务FCFS-1" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230054339.png" alt="image-20240604230054339"></p><h5 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230112935.png" alt="image-20240604230112935"></p><h5 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230150696.png" alt="image-20240604230150696"></p><h5 id="循环扫描算法C-SCAN"><a href="#循环扫描算法C-SCAN" class="headerlink" title="循环扫描算法C-SCAN"></a>循环扫描算法C-SCAN</h5><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230214184.png" alt="image-20240604230214184"></p><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>FCFS</strong></td><td>公平、简单</td><td>平均寻道距离大，仅应用在磁盘I/O较少的场合</td></tr><tr><td><strong>SSTF</strong></td><td>性能比FCFS好</td><td>不能保证平均寻道时间最短，可能出现“饥饿”现象</td></tr><tr><td><strong>SCAN</strong></td><td>寻道性能好，可能避免“饥饿”现象</td><td>不利于远离磁头一端的访问请求</td></tr><tr><td><strong>C-SCAN</strong></td><td>消除了对两端磁道请求的不公平</td><td>-</td></tr></tbody></table></div><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230555816.png" alt="image-20240604230555816"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604230613371.png" alt="image-20240604230613371"></p><h4 id="7-5-提高I-O速度的主要途径"><a href="#7-5-提高I-O速度的主要途径" class="headerlink" title="7.5 提高I/O速度的主要途径"></a>7.5 提高I/O速度的主要途径</h4><ul><li>选择性能好的磁盘</li><li>并行化</li><li>采用适当的调度算法</li><li>设置磁盘高速缓冲区<ol><li>缓存形式<ul><li>独立缓存（固定大小）</li><li>以虚拟内存为缓存（弹性大小）</li></ul></li><li>数据交付<ul><li>直接交付（copy开销）</li><li>指针交付（内存管理复杂）</li></ul></li><li>置换算法：LRU</li><li>周期性写回：disk cache-&gt;磁盘</li></ol></li></ul><h4 id="7-6-廉价冗余磁盘阵列-RAID"><a href="#7-6-廉价冗余磁盘阵列-RAID" class="headerlink" title="7.6 廉价冗余磁盘阵列: RAID"></a>7.6 廉价冗余磁盘阵列: RAID</h4><ul><li>利用冗余技术提高可靠性</li><li>利用并行提高性能</li></ul><p>定义：把多种独立的硬盘（物理硬盘）按照不同方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据冗余的技术。</p><p>组成磁盘阵列的不同方式：RAID级别。</p><p>数据冗余的功能是在用户数据一旦发生损坏后，利用冗余信息可以使损失数据得以恢复，从而保障了用户数据的安全性。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>成本低，功耗小，传输速率高</li></ul><p>• RAID比起传统的大直径磁盘驱动器来，在同样的容量下，价格要低许多。</p><p>• RAID让很多磁盘驱动器==并行传输数据==，比单个磁盘驱动器提高几倍、几十倍甚至上百倍的速率。有效缓解了快速的CPU与慢速的磁盘之间的矛盾</p><ul><li>可提供容错功能</li></ul><p>• 普通磁盘驱动器只能通过CRC(循环冗余校验)码提供简单的容错，RAID建立在每个磁盘驱动器的硬件容错功能之上，可提供==更高的可靠性==。</p><h5 id="RAID分级"><a href="#RAID分级" class="headerlink" title="RAID分级"></a>RAID分级</h5><p>主流的RAID有7个级别。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604232954270.png" alt="image-20240604232954270"></p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604233050985.png" alt="image-20240604233050985"></p><h2 id="8-文件系统"><a href="#8-文件系统" class="headerlink" title="8 文件系统"></a>8 文件系统</h2><h3 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h3><h4 id="8-1-1-文件的概念"><a href="#8-1-1-文件的概念" class="headerlink" title="8.1.1 文件的概念"></a>8.1.1 文件的概念</h4><p>一组带标识的、在逻辑上有完整==意义==的==信息项==的序列。实际上是一组==字节序列==：一切皆文件。文件包括两部分：</p><ul><li>文件体：文件本身的内容；</li><li>文件说明：文件存储和管理的相关信息。</li></ul><h4 id="8-1-2-文件的形式"><a href="#8-1-2-文件的形式" class="headerlink" title="8.1.2 文件的形式"></a>8.1.2 文件的形式</h4><ul><li>以字节为单位的==流式结构==</li><li>==记录性文件==结构</li><li>==树形结构==</li></ul><h4 id="8-1-3-目录的概念"><a href="#8-1-3-目录的概念" class="headerlink" title="8.1.3 目录的概念"></a>8.1.3 目录的概念</h4><p>==由文件说明索引组成的用于文件检索的特殊文件==。内容主要是文件访问和控制的信息（不包括文件内容）。</p><h4 id="8-1-4-文件系统的功能"><a href="#8-1-4-文件系统的功能" class="headerlink" title="8.1.4 文件系统的功能"></a>8.1.4 文件系统的功能</h4><h3 id="8-2-目录的作用、内容、结构"><a href="#8-2-目录的作用、内容、结构" class="headerlink" title="8.2 目录的作用、内容、结构"></a>8.2 目录的作用、内容、结构</h3><p>根据用户给出的ASCII形式的文件名（路径名），迅速地定位到相应的文件控制块。</p><p>不同的系统采用不同的实现方法，一般分为两类：</p><p>§ 直接法：目录项＝文件名＋文件控制块（属性信息、在外存上的存放位置）。如MS-DOS/Windows；</p><p>§ 间接法：目录项＝文件名＋文件控制块的地址（索引号）。如Unix（inode）；</p><h3 id="8-3-文件系统实现技术"><a href="#8-3-文件系统实现技术" class="headerlink" title="8.3 文件系统实现技术"></a>8.3 文件系统实现技术</h3><h4 id="8-3-1-文件控制块"><a href="#8-3-1-文件控制块" class="headerlink" title="8.3.1 文件控制块"></a>8.3.1 文件控制块</h4><ul><li><p>基本信息</p><ul><li>文件名</li><li>物理位置</li><li>文件逻辑结构：有/无结构（记录文件，流式文件）</li><li>文件物理结构：如顺序，索引等</li></ul></li><li><p>访问控制信息</p><ul><li>文件所有者（属主）</li><li>访问权限</li></ul></li><li>使用信息<ul><li>创建时间，上一次修改时间，当前使用信息等。</li></ul></li></ul><h4 id="8-3-2-文件的逻辑结构：记录、流式"><a href="#8-3-2-文件的逻辑结构：记录、流式" class="headerlink" title="8.3.2 文件的逻辑结构：记录、流式"></a>8.3.2 文件的逻辑结构：记录、流式</h4><h4 id="8-3-3-文件的物理结构"><a href="#8-3-3-文件的物理结构" class="headerlink" title="8.3.3 文件的物理结构"></a>8.3.3 文件的物理结构</h4><h5 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h5><p>容易出现磁盘碎片，适合变化不大的文件</p><p>§ 优点：</p><p>§ 结构简单，实现容易，不需要额外的空间开销</p><p>§ 顺序存取和随机存取的效率高</p><p>§ 缺点：</p><p>§ 文件长度一经固定便不易改变；</p><p>§ 不利于文件的动态增加和修改；</p><h5 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h5><p>§ 优点：</p><p>§ 空间利用率高；能较好的利用外存空间；</p><p>§ 文件动态扩充和修改容易；</p><p>§ 顺序存取效率高；类似于存储管理中的页式</p><p>§ 缺点：</p><p>§ 随机存取效率太低，如果访问文件的最后的内容，实际</p><p>上是要访问整个文件。</p><p>§ 可靠性问题，如指针出错;</p><p>§ 链接指针占用一定的空间。</p><h5 id="索引文件：一级索引、多级索引"><a href="#索引文件：一级索引、多级索引" class="headerlink" title="索引文件：一级索引、多级索引"></a>索引文件：一级索引、多级索引</h5><p>§ 一个文件的信息存放在若干个不连续物理块中</p><p>§ 系统为每个文件建立一个专用数据结构：索引表，并将这些物理块的块号存放在该索引中。</p><p>§ 索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><p><img src="C:\Users\shael\AppData\Roaming\Typora\typora-user-images\image-20240604234653755.png" alt="image-20240604234653755"></p><h3 id="8-4-文件的共享、保护、保密"><a href="#8-4-文件的共享、保护、保密" class="headerlink" title="8.4 文件的共享、保护、保密"></a>8.4 文件的共享、保护、保密</h3><h4 id="8-4-1-保护文件的方法"><a href="#8-4-1-保护文件的方法" class="headerlink" title="8.4.1 保护文件的方法"></a>8.4.1 保护文件的方法</h4><ul><li>建立副本<ol><li>优点：方法简单</li><li>缺点：设备费用和系统开销增大</li><li>适用于短小且极为重要的文件</li></ol></li><li>定时转储</li><li>规定文件的权限</li></ul><h4 id="8-4-2-性能问题"><a href="#8-4-2-性能问题" class="headerlink" title="8.4.2 性能问题"></a>8.4.2 性能问题</h4><p>§ 磁盘服务：速度成为系统性能的主要瓶颈之一。因此，在设计文件系统时应尽可能减少磁盘访问次数。</p><p>§ 提高文件系统性能的方法：目录项分解、当前目录、磁盘碎片整理、==块高速缓存==、磁盘调度、提前读取、合理分配磁盘空间、数据的优化分布、RAID技术等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019/11/01/Hexo-Theme-Snail/"/>
      <url>/2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
